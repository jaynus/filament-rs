/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align> {
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::std::mem::transmute(self)
    }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
pub type size_t = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __uint64_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct utils_JobSystem {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct utils_Entity {
    pub mIdentity: utils_Entity_Type,
}
pub type utils_Entity_Type = u32;
#[test]
fn bindgen_test_layout_utils_Entity() {
    assert_eq!(
        ::std::mem::size_of::<utils_Entity>(),
        4usize,
        concat!("Size of: ", stringify!(utils_Entity))
    );
    assert_eq!(
        ::std::mem::align_of::<utils_Entity>(),
        4usize,
        concat!("Alignment of ", stringify!(utils_Entity))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<utils_Entity>())).mIdentity as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(utils_Entity),
            "::",
            stringify!(mIdentity)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct utils_EntityManager {
    pub mGens: *mut u8,
}
#[repr(C)]
pub struct utils_EntityManager_Listener__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct utils_EntityManager_Listener {
    pub vtable_: *const utils_EntityManager_Listener__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_utils_EntityManager_Listener() {
    assert_eq!(
        ::std::mem::size_of::<utils_EntityManager_Listener>(),
        8usize,
        concat!("Size of: ", stringify!(utils_EntityManager_Listener))
    );
    assert_eq!(
        ::std::mem::align_of::<utils_EntityManager_Listener>(),
        8usize,
        concat!("Alignment of ", stringify!(utils_EntityManager_Listener))
    );
}
pub const utils_EntityManager_GENERATION_SHIFT: ::std::os::raw::c_int = 17;
pub const utils_EntityManager_RAW_INDEX_COUNT: size_t = 131072;
pub const utils_EntityManager_INDEX_MASK: utils_Entity_Type = 131071;
#[test]
fn bindgen_test_layout_utils_EntityManager() {
    assert_eq!(
        ::std::mem::size_of::<utils_EntityManager>(),
        8usize,
        concat!("Size of: ", stringify!(utils_EntityManager))
    );
    assert_eq!(
        ::std::mem::align_of::<utils_EntityManager>(),
        8usize,
        concat!("Alignment of ", stringify!(utils_EntityManager))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<utils_EntityManager>())).mGens as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(utils_EntityManager),
            "::",
            stringify!(mGens)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5utils13EntityManager3getEv"]
    pub fn utils_EntityManager_get() -> *mut utils_EntityManager;
}
extern "C" {
    #[link_name = "\u{1}_ZN5utils13EntityManager6createEmPNS_6EntityE"]
    pub fn utils_EntityManager_create(
        this: *mut utils_EntityManager,
        n: size_t,
        entities: *mut utils_Entity,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5utils13EntityManager7destroyEmPNS_6EntityE"]
    pub fn utils_EntityManager_destroy(
        this: *mut utils_EntityManager,
        n: size_t,
        entities: *mut utils_Entity,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5utils13EntityManager16registerListenerEPNS0_8ListenerE"]
    pub fn utils_EntityManager_registerListener(
        this: *mut utils_EntityManager,
        l: *mut utils_EntityManager_Listener,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5utils13EntityManager18unregisterListenerEPNS0_8ListenerE"]
    pub fn utils_EntityManager_unregisterListener(
        this: *mut utils_EntityManager,
        l: *mut utils_EntityManager_Listener,
    );
}
impl utils_EntityManager {
    #[inline]
    pub unsafe fn get() -> *mut utils_EntityManager {
        utils_EntityManager_get()
    }
    #[inline]
    pub unsafe fn create(&mut self, n: size_t, entities: *mut utils_Entity) {
        utils_EntityManager_create(self, n, entities)
    }
    #[inline]
    pub unsafe fn destroy(&mut self, n: size_t, entities: *mut utils_Entity) {
        utils_EntityManager_destroy(self, n, entities)
    }
    #[inline]
    pub unsafe fn registerListener(&mut self, l: *mut utils_EntityManager_Listener) {
        utils_EntityManager_registerListener(self, l)
    }
    #[inline]
    pub unsafe fn unregisterListener(&mut self, l: *mut utils_EntityManager_Listener) {
        utils_EntityManager_unregisterListener(self, l)
    }
}
pub type filament_math_float2 = [u32; 2usize];
pub type filament_math_float3 = [u32; 3usize];
pub type filament_math_float4 = [u32; 4usize];
pub type filament_math_mat4 = u8;
#[repr(u8)]
#[doc = " Selects which driver a particular Engine should use."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum filament_backend_Backend {
    #[doc = "!< Automatically selects an appropriate driver for the platform."]
    DEFAULT = 0,
    #[doc = "!< Selects the OpenGL driver (which supports OpenGL ES as well)."]
    OPENGL = 1,
    #[doc = "!< Selects the Vulkan driver if the platform supports it."]
    VULKAN = 2,
    #[doc = "!< Selects the Metal driver if the platform supports it."]
    METAL = 3,
    #[doc = "!< Selects the no-op driver for testing purposes."]
    NOOP = 4,
}
impl filament_backend_TargetBufferFlags {
    pub const COLOR: filament_backend_TargetBufferFlags =
        filament_backend_TargetBufferFlags::COLOR0;
}
#[repr(u8)]
#[doc = " Bitmask for selecting render buffers"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum filament_backend_TargetBufferFlags {
    #[doc = "!< No buffer selected."]
    NONE = 0,
    #[doc = "!< Color buffer selected."]
    COLOR0 = 1,
    #[doc = "!< Color buffer selected."]
    COLOR1 = 2,
    #[doc = "!< Color buffer selected."]
    COLOR2 = 4,
    #[doc = "!< Color buffer selected."]
    COLOR3 = 8,
    COLOR_ALL = 15,
    #[doc = "!< Depth buffer selected."]
    DEPTH = 16,
    #[doc = "!< Stencil buffer selected."]
    STENCIL = 32,
    #[doc = "!< depth and stencil buffer selected."]
    DEPTH_AND_STENCIL = 48,
    #[doc = "!< Color, depth and stencil buffer selected."]
    ALL = 63,
}
#[repr(u8)]
#[doc = " Frequency at which a buffer is expected to be modified and used. This is used as an hint"]
#[doc = " for the driver to make better decisions about managing memory internally."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum filament_backend_BufferUsage {
    #[doc = "!< content modified once, used many times"]
    STATIC = 0,
    #[doc = "!< content modified frequently, used many times"]
    DYNAMIC = 1,
    #[doc = "!< content invalidated and modified frequently, used many times"]
    STREAM = 2,
}
#[doc = " Defines a viewport, which is the origin and extent of the clip-space."]
#[doc = " All drawing is clipped to the viewport."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct filament_backend_Viewport {
    #[doc = "!< left coordinate in window space."]
    pub left: i32,
    #[doc = "!< bottom coordinate in window space."]
    pub bottom: i32,
    #[doc = "!< width in pixels"]
    pub width: u32,
    #[doc = "!< height in pixels"]
    pub height: u32,
}
#[test]
fn bindgen_test_layout_filament_backend_Viewport() {
    assert_eq!(
        ::std::mem::size_of::<filament_backend_Viewport>(),
        16usize,
        concat!("Size of: ", stringify!(filament_backend_Viewport))
    );
    assert_eq!(
        ::std::mem::align_of::<filament_backend_Viewport>(),
        4usize,
        concat!("Alignment of ", stringify!(filament_backend_Viewport))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<filament_backend_Viewport>())).left as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_backend_Viewport),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_backend_Viewport>())).bottom as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_backend_Viewport),
            "::",
            stringify!(bottom)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<filament_backend_Viewport>())).width as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_backend_Viewport),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_backend_Viewport>())).height as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_backend_Viewport),
            "::",
            stringify!(height)
        )
    );
}
#[repr(i8)]
#[doc = " Error codes for Fence::wait()"]
#[doc = " @see Fence, Fence::wait()"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum filament_backend_FenceStatus {
    #[doc = "!< An error occured. The Fence condition is not satisfied."]
    ERROR = -1,
    #[doc = "!< The Fence condition is satisfied."]
    CONDITION_SATISFIED = 0,
    #[doc = "!< wait()'s timeout expired. The Fence condition is not satisfied."]
    TIMEOUT_EXPIRED = 1,
}
#[repr(i8)]
#[doc = " Status codes for sync objects"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum filament_backend_SyncStatus {
    #[doc = "!< An error occured. The Sync is not signaled."]
    ERROR = -1,
    #[doc = "!< The Sync is signaled."]
    SIGNALED = 0,
    #[doc = "!< The Sync is not signaled yet"]
    NOT_SIGNALED = 1,
}
#[repr(u8)]
#[doc = " Shader model."]
#[doc = ""]
#[doc = " These enumerants are used across all backends and refer to a level of functionality, rather"]
#[doc = " than to an OpenGL specific shader model."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum filament_backend_ShaderModel {
    #[doc = "! For testing"]
    UNKNOWN = 0,
    #[doc = "!< Mobile level functionality"]
    GL_ES_30 = 1,
    #[doc = "!< Desktop level functionality"]
    GL_CORE_41 = 2,
}
#[repr(u8)]
#[doc = " Primitive types"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum filament_backend_PrimitiveType {
    #[doc = "!< points"]
    POINTS = 0,
    #[doc = "!< lines"]
    LINES = 1,
    #[doc = "!< triangles"]
    TRIANGLES = 4,
    NONE = 255,
}
#[repr(u8)]
#[doc = " Supported uniform types"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum filament_backend_UniformType {
    BOOL = 0,
    BOOL2 = 1,
    BOOL3 = 2,
    BOOL4 = 3,
    FLOAT = 4,
    FLOAT2 = 5,
    FLOAT3 = 6,
    FLOAT4 = 7,
    INT = 8,
    INT2 = 9,
    INT3 = 10,
    INT4 = 11,
    UINT = 12,
    UINT2 = 13,
    UINT3 = 14,
    UINT4 = 15,
    #[doc = "!< a 3x3 float matrix"]
    MAT3 = 16,
    #[doc = "!< a 4x4 float matrix"]
    MAT4 = 17,
}
#[repr(u8)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum filament_backend_Precision {
    LOW = 0,
    MEDIUM = 1,
    HIGH = 2,
    DEFAULT = 3,
}
#[repr(u8)]
#[doc = "! Texture sampler type"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum filament_backend_SamplerType {
    #[doc = "!< 2D texture"]
    SAMPLER_2D = 0,
    #[doc = "!< 2D array texture"]
    SAMPLER_2D_ARRAY = 1,
    #[doc = "!< Cube map texture"]
    SAMPLER_CUBEMAP = 2,
    #[doc = "!< External texture"]
    SAMPLER_EXTERNAL = 3,
}
#[repr(u8)]
#[doc = "! Texture sampler format"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum filament_backend_SamplerFormat {
    #[doc = "!< signed integer sampler"]
    INT = 0,
    #[doc = "!< unsigned integer sampler"]
    UINT = 1,
    #[doc = "!< float sampler"]
    FLOAT = 2,
    #[doc = "!< shadow sampler (PCF)"]
    SHADOW = 3,
}
#[repr(u8)]
#[doc = " Supported element types"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum filament_backend_ElementType {
    BYTE = 0,
    BYTE2 = 1,
    BYTE3 = 2,
    BYTE4 = 3,
    UBYTE = 4,
    UBYTE2 = 5,
    UBYTE3 = 6,
    UBYTE4 = 7,
    SHORT = 8,
    SHORT2 = 9,
    SHORT3 = 10,
    SHORT4 = 11,
    USHORT = 12,
    USHORT2 = 13,
    USHORT3 = 14,
    USHORT4 = 15,
    INT = 16,
    UINT = 17,
    FLOAT = 18,
    FLOAT2 = 19,
    FLOAT3 = 20,
    FLOAT4 = 21,
    HALF = 22,
    HALF2 = 23,
    HALF3 = 24,
    HALF4 = 25,
}
#[repr(u8)]
#[doc = "! Face culling Mode"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum filament_backend_CullingMode {
    #[doc = "!< No culling, front and back faces are visible"]
    NONE = 0,
    #[doc = "!< Front face culling, only back faces are visible"]
    FRONT = 1,
    #[doc = "!< Back face culling, only front faces are visible"]
    BACK = 2,
    #[doc = "!< Front and Back, geometry is not visible"]
    FRONT_AND_BACK = 3,
}
#[repr(u8)]
#[doc = "! Pixel Data Format"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum filament_backend_PixelDataFormat {
    #[doc = "!< One Red channel, float"]
    R = 0,
    #[doc = "!< One Red channel, integer"]
    R_INTEGER = 1,
    #[doc = "!< Two Red and Green channels, float"]
    RG = 2,
    #[doc = "!< Two Red and Green channels, integer"]
    RG_INTEGER = 3,
    #[doc = "!< Three Red, Green and Blue channels, float"]
    RGB = 4,
    #[doc = "!< Three Red, Green and Blue channels, integer"]
    RGB_INTEGER = 5,
    #[doc = "!< Four Red, Green, Blue and Alpha channels, float"]
    RGBA = 6,
    #[doc = "!< Four Red, Green, Blue and Alpha channels, integer"]
    RGBA_INTEGER = 7,
    UNUSED = 8,
    #[doc = "!< Depth, 16-bit or 24-bits usually"]
    DEPTH_COMPONENT = 9,
    #[doc = "!< Two Depth (24-bits) + Stencil (8-bits) channels"]
    DEPTH_STENCIL = 10,
    ALPHA = 11,
}
#[repr(u8)]
#[doc = "! Pixel Data Type"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum filament_backend_PixelDataType {
    #[doc = "!< unsigned byte"]
    UBYTE = 0,
    #[doc = "!< signed byte"]
    BYTE = 1,
    #[doc = "!< unsigned short (16-bit)"]
    USHORT = 2,
    #[doc = "!< signed short (16-bit)"]
    SHORT = 3,
    #[doc = "!< unsigned int (16-bit)"]
    UINT = 4,
    #[doc = "!< signed int (32-bit)"]
    INT = 5,
    #[doc = "!< half-float (16-bit float)"]
    HALF = 6,
    #[doc = "!< float (32-bits float)"]
    FLOAT = 7,
    #[doc = "!< compressed pixels, @see CompressedPixelDataType"]
    COMPRESSED = 8,
    #[doc = "!< three low precision floating-point numbers"]
    UINT_10F_11F_11F_REV = 9,
    #[doc = "!< unsigned int (16-bit), encodes 3 RGB channels"]
    USHORT_565 = 10,
}
#[repr(u16)]
#[doc = "! Compressed pixel data types"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum filament_backend_CompressedPixelDataType {
    EAC_R11 = 0,
    EAC_R11_SIGNED = 1,
    EAC_RG11 = 2,
    EAC_RG11_SIGNED = 3,
    ETC2_RGB8 = 4,
    ETC2_SRGB8 = 5,
    ETC2_RGB8_A1 = 6,
    ETC2_SRGB8_A1 = 7,
    ETC2_EAC_RGBA8 = 8,
    ETC2_EAC_SRGBA8 = 9,
    DXT1_RGB = 10,
    DXT1_RGBA = 11,
    DXT3_RGBA = 12,
    DXT5_RGBA = 13,
    DXT1_SRGB = 14,
    DXT1_SRGBA = 15,
    DXT3_SRGBA = 16,
    DXT5_SRGBA = 17,
    RGBA_ASTC_4x4 = 18,
    RGBA_ASTC_5x4 = 19,
    RGBA_ASTC_5x5 = 20,
    RGBA_ASTC_6x5 = 21,
    RGBA_ASTC_6x6 = 22,
    RGBA_ASTC_8x5 = 23,
    RGBA_ASTC_8x6 = 24,
    RGBA_ASTC_8x8 = 25,
    RGBA_ASTC_10x5 = 26,
    RGBA_ASTC_10x6 = 27,
    RGBA_ASTC_10x8 = 28,
    RGBA_ASTC_10x10 = 29,
    RGBA_ASTC_12x10 = 30,
    RGBA_ASTC_12x12 = 31,
    SRGB8_ALPHA8_ASTC_4x4 = 32,
    SRGB8_ALPHA8_ASTC_5x4 = 33,
    SRGB8_ALPHA8_ASTC_5x5 = 34,
    SRGB8_ALPHA8_ASTC_6x5 = 35,
    SRGB8_ALPHA8_ASTC_6x6 = 36,
    SRGB8_ALPHA8_ASTC_8x5 = 37,
    SRGB8_ALPHA8_ASTC_8x6 = 38,
    SRGB8_ALPHA8_ASTC_8x8 = 39,
    SRGB8_ALPHA8_ASTC_10x5 = 40,
    SRGB8_ALPHA8_ASTC_10x6 = 41,
    SRGB8_ALPHA8_ASTC_10x8 = 42,
    SRGB8_ALPHA8_ASTC_10x10 = 43,
    SRGB8_ALPHA8_ASTC_12x10 = 44,
    SRGB8_ALPHA8_ASTC_12x12 = 45,
}
#[repr(u16)]
#[doc = " Supported texel formats"]
#[doc = " These formats are typically used to specify a texture's internal storage format."]
#[doc = ""]
#[doc = " Enumerants syntax format"]
#[doc = " ========================"]
#[doc = ""]
#[doc = " `[components][size][type]`"]
#[doc = ""]
#[doc = " `components` : List of stored components by this format.\\n"]
#[doc = " `size`       : Size in bit of each component.\\n"]
#[doc = " `type`       : Type this format is stored as.\\n"]
#[doc = ""]
#[doc = ""]
#[doc = " Name     | Component"]
#[doc = " :--------|:-------------------------------"]
#[doc = " R        | Linear Red"]
#[doc = " RG       | Linear Red, Green"]
#[doc = " RGB      | Linear Red, Green, Blue"]
#[doc = " RGBA     | Linear Red, Green Blue, Alpha"]
#[doc = " SRGB     | sRGB encoded Red, Green, Blue"]
#[doc = " DEPTH    | Depth"]
#[doc = " STENCIL  | Stencil"]
#[doc = ""]
#[doc = " \\n"]
#[doc = " Name     | Type"]
#[doc = " :--------|:---------------------------------------------------"]
#[doc = " (none)   | Unsigned Normalized Integer [0, 1]"]
#[doc = " _SNORM   | Signed Normalized Integer [-1, 1]"]
#[doc = " UI       | Unsigned Integer @f$ [0, 2^{size}] @f$"]
#[doc = " I        | Signed Integer @f$ [-2^{size-1}, 2^{size-1}-1] @f$"]
#[doc = " F        | Floating-point"]
#[doc = ""]
#[doc = ""]
#[doc = " Special color formats"]
#[doc = " ---------------------"]
#[doc = ""]
#[doc = " There are a few special color formats that don't follow the convention above:"]
#[doc = ""]
#[doc = " Name             | Format"]
#[doc = " :----------------|:--------------------------------------------------------------------------"]
#[doc = " RGB565           |  5-bits for R and B, 6-bits for G."]
#[doc = " RGB5_A1          |  5-bits for R, G and B, 1-bit for A."]
#[doc = " RGB10_A2         | 10-bits for R, G and B, 2-bits for A."]
#[doc = " RGB9_E5          | **Unsigned** floating point. 9-bits mantissa for RGB, 5-bits shared exponent"]
#[doc = " R11F_G11F_B10F   | **Unsigned** floating point. 6-bits mantissa, for R and G, 5-bits for B. 5-bits exponent."]
#[doc = " SRGB8_A8         | sRGB 8-bits with linear 8-bits alpha."]
#[doc = " DEPTH24_STENCIL8 | 24-bits unsigned normalized integer depth, 8-bits stencil."]
#[doc = " DEPTH32F_STENCIL8| 32-bits floating-point depth, 8-bits stencil."]
#[doc = ""]
#[doc = ""]
#[doc = " Compressed texture formats"]
#[doc = " --------------------------"]
#[doc = ""]
#[doc = " Many compressed texture formats are supported as well, which include (but are not limited to)"]
#[doc = " the following list:"]
#[doc = ""]
#[doc = " Name             | Format"]
#[doc = " :----------------|:--------------------------------------------------------------------------"]
#[doc = " EAC_R11          | Compresses R11UI"]
#[doc = " EAC_R11_SIGNED   | Compresses R11I"]
#[doc = " EAC_RG11         | Compresses RG11UI"]
#[doc = " EAC_RG11_SIGNED  | Compresses RG11I"]
#[doc = " ETC2_RGB8        | Compresses RGB8"]
#[doc = " ETC2_SRGB8       | compresses SRGB8"]
#[doc = " ETC2_EAC_RGBA8   | Compresses RGBA8"]
#[doc = " ETC2_EAC_SRGBA8  | Compresses SRGB8_A8"]
#[doc = " ETC2_RGB8_A1     | Compresses RGB8 with 1-bit alpha"]
#[doc = " ETC2_SRGB8_A1    | Compresses sRGB8 with 1-bit alpha"]
#[doc = ""]
#[doc = ""]
#[doc = " @see Texture"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum filament_backend_TextureFormat {
    R8 = 0,
    R8_SNORM = 1,
    R8UI = 2,
    R8I = 3,
    STENCIL8 = 4,
    R16F = 5,
    R16UI = 6,
    R16I = 7,
    RG8 = 8,
    RG8_SNORM = 9,
    RG8UI = 10,
    RG8I = 11,
    RGB565 = 12,
    RGB9_E5 = 13,
    RGB5_A1 = 14,
    RGBA4 = 15,
    DEPTH16 = 16,
    RGB8 = 17,
    SRGB8 = 18,
    RGB8_SNORM = 19,
    RGB8UI = 20,
    RGB8I = 21,
    DEPTH24 = 22,
    R32F = 23,
    R32UI = 24,
    R32I = 25,
    RG16F = 26,
    RG16UI = 27,
    RG16I = 28,
    R11F_G11F_B10F = 29,
    RGBA8 = 30,
    SRGB8_A8 = 31,
    RGBA8_SNORM = 32,
    UNUSED = 33,
    RGB10_A2 = 34,
    RGBA8UI = 35,
    RGBA8I = 36,
    DEPTH32F = 37,
    DEPTH24_STENCIL8 = 38,
    DEPTH32F_STENCIL8 = 39,
    RGB16F = 40,
    RGB16UI = 41,
    RGB16I = 42,
    RG32F = 43,
    RG32UI = 44,
    RG32I = 45,
    RGBA16F = 46,
    RGBA16UI = 47,
    RGBA16I = 48,
    RGB32F = 49,
    RGB32UI = 50,
    RGB32I = 51,
    RGBA32F = 52,
    RGBA32UI = 53,
    RGBA32I = 54,
    EAC_R11 = 55,
    EAC_R11_SIGNED = 56,
    EAC_RG11 = 57,
    EAC_RG11_SIGNED = 58,
    ETC2_RGB8 = 59,
    ETC2_SRGB8 = 60,
    ETC2_RGB8_A1 = 61,
    ETC2_SRGB8_A1 = 62,
    ETC2_EAC_RGBA8 = 63,
    ETC2_EAC_SRGBA8 = 64,
    DXT1_RGB = 65,
    DXT1_RGBA = 66,
    DXT3_RGBA = 67,
    DXT5_RGBA = 68,
    DXT1_SRGB = 69,
    DXT1_SRGBA = 70,
    DXT3_SRGBA = 71,
    DXT5_SRGBA = 72,
    RGBA_ASTC_4x4 = 73,
    RGBA_ASTC_5x4 = 74,
    RGBA_ASTC_5x5 = 75,
    RGBA_ASTC_6x5 = 76,
    RGBA_ASTC_6x6 = 77,
    RGBA_ASTC_8x5 = 78,
    RGBA_ASTC_8x6 = 79,
    RGBA_ASTC_8x8 = 80,
    RGBA_ASTC_10x5 = 81,
    RGBA_ASTC_10x6 = 82,
    RGBA_ASTC_10x8 = 83,
    RGBA_ASTC_10x10 = 84,
    RGBA_ASTC_12x10 = 85,
    RGBA_ASTC_12x12 = 86,
    SRGB8_ALPHA8_ASTC_4x4 = 87,
    SRGB8_ALPHA8_ASTC_5x4 = 88,
    SRGB8_ALPHA8_ASTC_5x5 = 89,
    SRGB8_ALPHA8_ASTC_6x5 = 90,
    SRGB8_ALPHA8_ASTC_6x6 = 91,
    SRGB8_ALPHA8_ASTC_8x5 = 92,
    SRGB8_ALPHA8_ASTC_8x6 = 93,
    SRGB8_ALPHA8_ASTC_8x8 = 94,
    SRGB8_ALPHA8_ASTC_10x5 = 95,
    SRGB8_ALPHA8_ASTC_10x6 = 96,
    SRGB8_ALPHA8_ASTC_10x8 = 97,
    SRGB8_ALPHA8_ASTC_10x10 = 98,
    SRGB8_ALPHA8_ASTC_12x10 = 99,
    SRGB8_ALPHA8_ASTC_12x12 = 100,
}
#[repr(u8)]
#[doc = "! Bitmask describing the intended Texture Usage"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum filament_backend_TextureUsage {
    #[doc = "!< Texture can be used as a color attachment"]
    COLOR_ATTACHMENT = 1,
    #[doc = "!< Texture can be used as a depth attachment"]
    DEPTH_ATTACHMENT = 2,
    #[doc = "!< Texture can be used as a stencil attachment"]
    STENCIL_ATTACHMENT = 4,
    #[doc = "!< Data can be uploaded into this texture (default)"]
    UPLOADABLE = 8,
    #[doc = "!< Texture can be sampled (default)"]
    SAMPLEABLE = 16,
    #[doc = "!< Default texture usage"]
    DEFAULT = 24,
}
#[repr(i32)]
#[doc = "! Texture swizzle"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum filament_backend_TextureSwizzle {
    SUBSTITUTE_ZERO = 0,
    SUBSTITUTE_ONE = 1,
    CHANNEL_0 = 2,
    CHANNEL_1 = 3,
    CHANNEL_2 = 4,
    CHANNEL_3 = 5,
}
#[repr(u8)]
#[doc = "! Texture Cubemap Face"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum filament_backend_TextureCubemapFace {
    #[doc = "!< +x face"]
    POSITIVE_X = 0,
    #[doc = "!< -x face"]
    NEGATIVE_X = 1,
    #[doc = "!< +y face"]
    POSITIVE_Y = 2,
    #[doc = "!< -y face"]
    NEGATIVE_Y = 3,
    #[doc = "!< +z face"]
    POSITIVE_Z = 4,
    #[doc = "!< -z face"]
    NEGATIVE_Z = 5,
}
#[doc = "! Face offsets for all faces of a cubemap"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct filament_backend_FaceOffsets {
    pub __bindgen_anon_1: filament_backend_FaceOffsets__bindgen_ty_1,
}
pub type filament_backend_FaceOffsets_size_type = size_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct filament_backend_FaceOffsets__bindgen_ty_1 {
    pub __bindgen_anon_1:
        __BindgenUnionField<filament_backend_FaceOffsets__bindgen_ty_1__bindgen_ty_1>,
    pub offsets: __BindgenUnionField<[filament_backend_FaceOffsets_size_type; 6usize]>,
    pub bindgen_union_field: [u64; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct filament_backend_FaceOffsets__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "!< +x face offset in bytes"]
    pub px: filament_backend_FaceOffsets_size_type,
    #[doc = "!< -x face offset in bytes"]
    pub nx: filament_backend_FaceOffsets_size_type,
    #[doc = "!< +y face offset in bytes"]
    pub py: filament_backend_FaceOffsets_size_type,
    #[doc = "!< -y face offset in bytes"]
    pub ny: filament_backend_FaceOffsets_size_type,
    #[doc = "!< +z face offset in bytes"]
    pub pz: filament_backend_FaceOffsets_size_type,
    #[doc = "!< -z face offset in bytes"]
    pub nz: filament_backend_FaceOffsets_size_type,
}
#[test]
fn bindgen_test_layout_filament_backend_FaceOffsets__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<filament_backend_FaceOffsets__bindgen_ty_1__bindgen_ty_1>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(filament_backend_FaceOffsets__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<filament_backend_FaceOffsets__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(filament_backend_FaceOffsets__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_backend_FaceOffsets__bindgen_ty_1__bindgen_ty_1>())).px
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_backend_FaceOffsets__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(px)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_backend_FaceOffsets__bindgen_ty_1__bindgen_ty_1>())).nx
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_backend_FaceOffsets__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(nx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_backend_FaceOffsets__bindgen_ty_1__bindgen_ty_1>())).py
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_backend_FaceOffsets__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(py)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_backend_FaceOffsets__bindgen_ty_1__bindgen_ty_1>())).ny
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_backend_FaceOffsets__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(ny)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_backend_FaceOffsets__bindgen_ty_1__bindgen_ty_1>())).pz
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_backend_FaceOffsets__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(pz)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_backend_FaceOffsets__bindgen_ty_1__bindgen_ty_1>())).nz
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_backend_FaceOffsets__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(nz)
        )
    );
}
#[test]
fn bindgen_test_layout_filament_backend_FaceOffsets__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<filament_backend_FaceOffsets__bindgen_ty_1>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(filament_backend_FaceOffsets__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<filament_backend_FaceOffsets__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(filament_backend_FaceOffsets__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_backend_FaceOffsets__bindgen_ty_1>())).offsets
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_backend_FaceOffsets__bindgen_ty_1),
            "::",
            stringify!(offsets)
        )
    );
}
#[test]
fn bindgen_test_layout_filament_backend_FaceOffsets() {
    assert_eq!(
        ::std::mem::size_of::<filament_backend_FaceOffsets>(),
        48usize,
        concat!("Size of: ", stringify!(filament_backend_FaceOffsets))
    );
    assert_eq!(
        ::std::mem::align_of::<filament_backend_FaceOffsets>(),
        8usize,
        concat!("Alignment of ", stringify!(filament_backend_FaceOffsets))
    );
}
#[repr(u8)]
#[doc = "! Sampler Wrap mode"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum filament_backend_SamplerWrapMode {
    #[doc = "!< clamp-to-edge. The edge of the texture extends to infinity."]
    CLAMP_TO_EDGE = 0,
    #[doc = "!< repeat. The texture infinitely repeats in the wrap direction."]
    REPEAT = 1,
    #[doc = "!< mirrored-repeat. The texture infinitely repeats and mirrors in the wrap direction."]
    MIRRORED_REPEAT = 2,
}
#[repr(u8)]
#[doc = "! Sampler minification filter"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum filament_backend_SamplerMinFilter {
    #[doc = "!< No filtering. Nearest neighbor is used."]
    NEAREST = 0,
    #[doc = "!< Box filtering. Weighted average of 4 neighbors is used."]
    LINEAR = 1,
    #[doc = "!< Mip-mapping is activated. But no filtering occurs."]
    NEAREST_MIPMAP_NEAREST = 2,
    #[doc = "!< Box filtering within a mip-map level."]
    LINEAR_MIPMAP_NEAREST = 3,
    #[doc = "!< Mip-map levels are interpolated, but no other filtering occurs."]
    NEAREST_MIPMAP_LINEAR = 4,
    #[doc = "!< Both interpolated Mip-mapping and linear filtering are used."]
    LINEAR_MIPMAP_LINEAR = 5,
}
#[repr(u8)]
#[doc = "! Sampler magnification filter"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum filament_backend_SamplerMagFilter {
    #[doc = "!< No filtering. Nearest neighbor is used."]
    NEAREST = 0,
    #[doc = "!< Box filtering. Weighted average of 4 neighbors is used."]
    LINEAR = 1,
}
#[repr(u8)]
#[doc = "! Sampler compare mode"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum filament_backend_SamplerCompareMode {
    NONE = 0,
    COMPARE_TO_TEXTURE = 1,
}
#[repr(u8)]
#[doc = "! comparison function for the depth sampler"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum filament_backend_SamplerCompareFunc {
    #[doc = "!< Less or equal"]
    LE = 0,
    #[doc = "!< Greater or equal"]
    GE = 1,
    #[doc = "!< Strictly less than"]
    L = 2,
    #[doc = "!< Strictly greater than"]
    G = 3,
    #[doc = "!< Equal"]
    E = 4,
    #[doc = "!< Not equal"]
    NE = 5,
    #[doc = "!< Always. Depth testing is deactivated."]
    A = 6,
    #[doc = "!< Never. The depth test always fails."]
    N = 7,
}
#[doc = "! Sampler paramters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct filament_backend_SamplerParams {
    pub __bindgen_anon_1: filament_backend_SamplerParams__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct filament_backend_SamplerParams__bindgen_ty_1 {
    pub __bindgen_anon_1:
        __BindgenUnionField<filament_backend_SamplerParams__bindgen_ty_1__bindgen_ty_1>,
    pub u: __BindgenUnionField<u32>,
    pub bindgen_union_field: u32,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct filament_backend_SamplerParams__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_filament_backend_SamplerParams__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<filament_backend_SamplerParams__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(filament_backend_SamplerParams__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<filament_backend_SamplerParams__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(filament_backend_SamplerParams__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl filament_backend_SamplerParams__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn filterMag(&self) -> filament_backend_SamplerMagFilter {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_filterMag(&mut self, val: filament_backend_SamplerMagFilter) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn filterMin(&self) -> filament_backend_SamplerMinFilter {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_filterMin(&mut self, val: filament_backend_SamplerMinFilter) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn wrapS(&self) -> filament_backend_SamplerWrapMode {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_wrapS(&mut self, val: filament_backend_SamplerWrapMode) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn wrapT(&self) -> filament_backend_SamplerWrapMode {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_wrapT(&mut self, val: filament_backend_SamplerWrapMode) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn wrapR(&self) -> filament_backend_SamplerWrapMode {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_wrapR(&mut self, val: filament_backend_SamplerWrapMode) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn anisotropyLog2(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_anisotropyLog2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn compareMode(&self) -> filament_backend_SamplerCompareMode {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_compareMode(&mut self, val: filament_backend_SamplerCompareMode) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn padding0(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_padding0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn compareFunc(&self) -> filament_backend_SamplerCompareFunc {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_compareFunc(&mut self, val: filament_backend_SamplerCompareFunc) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn padding1(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_padding1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn padding2(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u8) }
    }
    #[inline]
    pub fn set_padding2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        filterMag: filament_backend_SamplerMagFilter,
        filterMin: filament_backend_SamplerMinFilter,
        wrapS: filament_backend_SamplerWrapMode,
        wrapT: filament_backend_SamplerWrapMode,
        wrapR: filament_backend_SamplerWrapMode,
        anisotropyLog2: u8,
        compareMode: filament_backend_SamplerCompareMode,
        padding0: u8,
        compareFunc: filament_backend_SamplerCompareFunc,
        padding1: u8,
        padding2: u8,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let filterMag: u8 = unsafe { ::std::mem::transmute(filterMag) };
            filterMag as u64
        });
        __bindgen_bitfield_unit.set(1usize, 3u8, {
            let filterMin: u8 = unsafe { ::std::mem::transmute(filterMin) };
            filterMin as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let wrapS: u8 = unsafe { ::std::mem::transmute(wrapS) };
            wrapS as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let wrapT: u8 = unsafe { ::std::mem::transmute(wrapT) };
            wrapT as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let wrapR: u8 = unsafe { ::std::mem::transmute(wrapR) };
            wrapR as u64
        });
        __bindgen_bitfield_unit.set(10usize, 3u8, {
            let anisotropyLog2: u8 = unsafe { ::std::mem::transmute(anisotropyLog2) };
            anisotropyLog2 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let compareMode: u8 = unsafe { ::std::mem::transmute(compareMode) };
            compareMode as u64
        });
        __bindgen_bitfield_unit.set(14usize, 2u8, {
            let padding0: u8 = unsafe { ::std::mem::transmute(padding0) };
            padding0 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 3u8, {
            let compareFunc: u8 = unsafe { ::std::mem::transmute(compareFunc) };
            compareFunc as u64
        });
        __bindgen_bitfield_unit.set(19usize, 5u8, {
            let padding1: u8 = unsafe { ::std::mem::transmute(padding1) };
            padding1 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let padding2: u8 = unsafe { ::std::mem::transmute(padding2) };
            padding2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_filament_backend_SamplerParams__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<filament_backend_SamplerParams__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(filament_backend_SamplerParams__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<filament_backend_SamplerParams__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(filament_backend_SamplerParams__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_backend_SamplerParams__bindgen_ty_1>())).u as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_backend_SamplerParams__bindgen_ty_1),
            "::",
            stringify!(u)
        )
    );
}
#[test]
fn bindgen_test_layout_filament_backend_SamplerParams() {
    assert_eq!(
        ::std::mem::size_of::<filament_backend_SamplerParams>(),
        4usize,
        concat!("Size of: ", stringify!(filament_backend_SamplerParams))
    );
    assert_eq!(
        ::std::mem::align_of::<filament_backend_SamplerParams>(),
        4usize,
        concat!("Alignment of ", stringify!(filament_backend_SamplerParams))
    );
}
#[repr(u8)]
#[doc = "! blending equation function"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum filament_backend_BlendEquation {
    #[doc = "!< the fragment is added to the color buffer"]
    ADD = 0,
    #[doc = "!< the fragment is subtracted from the color buffer"]
    SUBTRACT = 1,
    #[doc = "!< the color buffer is subtracted from the fragment"]
    REVERSE_SUBTRACT = 2,
    #[doc = "!< the min between the fragment and color buffer"]
    MIN = 3,
    #[doc = "!< the max between the fragment and color buffer"]
    MAX = 4,
}
#[repr(u8)]
#[doc = "! blending function"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum filament_backend_BlendFunction {
    #[doc = "!< f(src, dst) = 0"]
    ZERO = 0,
    #[doc = "!< f(src, dst) = 1"]
    ONE = 1,
    #[doc = "!< f(src, dst) = src"]
    SRC_COLOR = 2,
    #[doc = "!< f(src, dst) = 1-src"]
    ONE_MINUS_SRC_COLOR = 3,
    #[doc = "!< f(src, dst) = dst"]
    DST_COLOR = 4,
    #[doc = "!< f(src, dst) = 1-dst"]
    ONE_MINUS_DST_COLOR = 5,
    #[doc = "!< f(src, dst) = src.a"]
    SRC_ALPHA = 6,
    #[doc = "!< f(src, dst) = 1-src.a"]
    ONE_MINUS_SRC_ALPHA = 7,
    #[doc = "!< f(src, dst) = dst.a"]
    DST_ALPHA = 8,
    #[doc = "!< f(src, dst) = 1-dst.a"]
    ONE_MINUS_DST_ALPHA = 9,
    #[doc = "!< f(src, dst) = (1,1,1) * min(src.a, 1 - dst.a), 1"]
    SRC_ALPHA_SATURATE = 10,
}
#[repr(i32)]
#[doc = "! Stream for external textures"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum filament_backend_StreamType {
    #[doc = "!< Not synchronized but copy-free. Good for video."]
    NATIVE = 0,
    #[doc = "!< Synchronized, but GL-only and incurs copies. Good for AR on devices before API 26."]
    TEXTURE_ID = 1,
    #[doc = "!< Synchronized, copy-free, and take a release callback. Good for AR but requires API 26+."]
    ACQUIRED = 2,
}
#[doc = "! Releases an ACQUIRED external texture, guaranteed to be called on the application thread."]
pub type filament_backend_StreamCallback = ::std::option::Option<
    unsafe extern "C" fn(image: *mut ::std::os::raw::c_void, user: *mut ::std::os::raw::c_void),
>;
#[doc = "! Vertex attribute descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct filament_backend_Attribute {
    #[doc = "!< attribute offset in bytes"]
    pub offset: u32,
    #[doc = "!< attribute stride in bytes"]
    pub stride: u8,
    #[doc = "!< attribute buffer index"]
    pub buffer: u8,
    #[doc = "!< attribute element type"]
    pub type_: filament_backend_ElementType,
    #[doc = "!< attribute flags"]
    pub flags: u8,
}
pub const filament_backend_Attribute_FLAG_NORMALIZED: u8 = 1;
pub const filament_backend_Attribute_FLAG_INTEGER_TARGET: u8 = 2;
#[test]
fn bindgen_test_layout_filament_backend_Attribute() {
    assert_eq!(
        ::std::mem::size_of::<filament_backend_Attribute>(),
        8usize,
        concat!("Size of: ", stringify!(filament_backend_Attribute))
    );
    assert_eq!(
        ::std::mem::align_of::<filament_backend_Attribute>(),
        4usize,
        concat!("Alignment of ", stringify!(filament_backend_Attribute))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_backend_Attribute>())).offset as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_backend_Attribute),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_backend_Attribute>())).stride as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_backend_Attribute),
            "::",
            stringify!(stride)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_backend_Attribute>())).buffer as *const _ as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_backend_Attribute),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_backend_Attribute>())).type_ as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_backend_Attribute),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_backend_Attribute>())).flags as *const _ as usize
        },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_backend_Attribute),
            "::",
            stringify!(flags)
        )
    );
}
pub type filament_backend_AttributeArray = u8;
#[doc = "! Raster state descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct filament_backend_RasterState {
    pub __bindgen_anon_1: filament_backend_RasterState__bindgen_ty_1,
}
pub use self::filament_backend_BlendEquation as filament_backend_RasterState_BlendEquation;
pub use self::filament_backend_BlendFunction as filament_backend_RasterState_BlendFunction;
pub use self::filament_backend_CullingMode as filament_backend_RasterState_CullingMode;
pub use self::filament_backend_SamplerCompareFunc as filament_backend_RasterState_DepthFunc;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct filament_backend_RasterState__bindgen_ty_1 {
    pub __bindgen_anon_1:
        __BindgenUnionField<filament_backend_RasterState__bindgen_ty_1__bindgen_ty_1>,
    pub u: __BindgenUnionField<u32>,
    pub bindgen_union_field: u32,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct filament_backend_RasterState__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_filament_backend_RasterState__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<filament_backend_RasterState__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(filament_backend_RasterState__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<filament_backend_RasterState__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(filament_backend_RasterState__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl filament_backend_RasterState__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn culling(&self) -> filament_backend_RasterState_CullingMode {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_culling(&mut self, val: filament_backend_RasterState_CullingMode) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn blendEquationRGB(&self) -> filament_backend_RasterState_BlendEquation {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_blendEquationRGB(&mut self, val: filament_backend_RasterState_BlendEquation) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn blendEquationAlpha(&self) -> filament_backend_RasterState_BlendEquation {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_blendEquationAlpha(&mut self, val: filament_backend_RasterState_BlendEquation) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn blendFunctionSrcRGB(&self) -> filament_backend_RasterState_BlendFunction {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_blendFunctionSrcRGB(&mut self, val: filament_backend_RasterState_BlendFunction) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn blendFunctionSrcAlpha(&self) -> filament_backend_RasterState_BlendFunction {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_blendFunctionSrcAlpha(&mut self, val: filament_backend_RasterState_BlendFunction) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn blendFunctionDstRGB(&self) -> filament_backend_RasterState_BlendFunction {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_blendFunctionDstRGB(&mut self, val: filament_backend_RasterState_BlendFunction) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn blendFunctionDstAlpha(&self) -> filament_backend_RasterState_BlendFunction {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_blendFunctionDstAlpha(&mut self, val: filament_backend_RasterState_BlendFunction) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn depthWrite(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_depthWrite(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn depthFunc(&self) -> filament_backend_RasterState_DepthFunc {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(25usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_depthFunc(&mut self, val: filament_backend_RasterState_DepthFunc) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(25usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn colorWrite(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_colorWrite(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn alphaToCoverage(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_alphaToCoverage(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inverseFrontFaces(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_inverseFrontFaces(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn padding(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_padding(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        culling: filament_backend_RasterState_CullingMode,
        blendEquationRGB: filament_backend_RasterState_BlendEquation,
        blendEquationAlpha: filament_backend_RasterState_BlendEquation,
        blendFunctionSrcRGB: filament_backend_RasterState_BlendFunction,
        blendFunctionSrcAlpha: filament_backend_RasterState_BlendFunction,
        blendFunctionDstRGB: filament_backend_RasterState_BlendFunction,
        blendFunctionDstAlpha: filament_backend_RasterState_BlendFunction,
        depthWrite: bool,
        depthFunc: filament_backend_RasterState_DepthFunc,
        colorWrite: bool,
        alphaToCoverage: bool,
        inverseFrontFaces: bool,
        padding: u8,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let culling: u8 = unsafe { ::std::mem::transmute(culling) };
            culling as u64
        });
        __bindgen_bitfield_unit.set(2usize, 3u8, {
            let blendEquationRGB: u8 = unsafe { ::std::mem::transmute(blendEquationRGB) };
            blendEquationRGB as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let blendEquationAlpha: u8 = unsafe { ::std::mem::transmute(blendEquationAlpha) };
            blendEquationAlpha as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let blendFunctionSrcRGB: u8 = unsafe { ::std::mem::transmute(blendFunctionSrcRGB) };
            blendFunctionSrcRGB as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let blendFunctionSrcAlpha: u8 = unsafe { ::std::mem::transmute(blendFunctionSrcAlpha) };
            blendFunctionSrcAlpha as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let blendFunctionDstRGB: u8 = unsafe { ::std::mem::transmute(blendFunctionDstRGB) };
            blendFunctionDstRGB as u64
        });
        __bindgen_bitfield_unit.set(20usize, 4u8, {
            let blendFunctionDstAlpha: u8 = unsafe { ::std::mem::transmute(blendFunctionDstAlpha) };
            blendFunctionDstAlpha as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let depthWrite: u8 = unsafe { ::std::mem::transmute(depthWrite) };
            depthWrite as u64
        });
        __bindgen_bitfield_unit.set(25usize, 3u8, {
            let depthFunc: u8 = unsafe { ::std::mem::transmute(depthFunc) };
            depthFunc as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let colorWrite: u8 = unsafe { ::std::mem::transmute(colorWrite) };
            colorWrite as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let alphaToCoverage: u8 = unsafe { ::std::mem::transmute(alphaToCoverage) };
            alphaToCoverage as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let inverseFrontFaces: u8 = unsafe { ::std::mem::transmute(inverseFrontFaces) };
            inverseFrontFaces as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let padding: u8 = unsafe { ::std::mem::transmute(padding) };
            padding as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_filament_backend_RasterState__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<filament_backend_RasterState__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(filament_backend_RasterState__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<filament_backend_RasterState__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(filament_backend_RasterState__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_backend_RasterState__bindgen_ty_1>())).u as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_backend_RasterState__bindgen_ty_1),
            "::",
            stringify!(u)
        )
    );
}
#[test]
fn bindgen_test_layout_filament_backend_RasterState() {
    assert_eq!(
        ::std::mem::size_of::<filament_backend_RasterState>(),
        4usize,
        concat!("Size of: ", stringify!(filament_backend_RasterState))
    );
    assert_eq!(
        ::std::mem::align_of::<filament_backend_RasterState>(),
        4usize,
        concat!("Alignment of ", stringify!(filament_backend_RasterState))
    );
}
#[repr(u8)]
#[doc = " \\privatesection"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum filament_backend_ShaderType {
    VERTEX = 0,
    FRAGMENT = 1,
}
#[doc = " Selects which buffers to clear at the beginning of the render pass, as well as which buffers"]
#[doc = " can be discarded at the beginning and end of the render pass."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct filament_backend_RenderPassFlags {
    #[doc = " bitmask indicating which buffers to clear at the beginning of a render pass."]
    #[doc = " This implies discard."]
    pub clear: filament_backend_TargetBufferFlags,
    #[doc = " bitmask indicating which buffers to discard at the beginning of a render pass."]
    #[doc = " Discarded buffers have uninitialized content, they must be entirely drawn over or cleared."]
    pub discardStart: filament_backend_TargetBufferFlags,
    #[doc = " bitmask indicating which buffers to discard at the end of a render pass."]
    #[doc = " Discarded buffers' content becomes invalid, they must not be read from again."]
    pub discardEnd: filament_backend_TargetBufferFlags,
}
#[test]
fn bindgen_test_layout_filament_backend_RenderPassFlags() {
    assert_eq!(
        ::std::mem::size_of::<filament_backend_RenderPassFlags>(),
        3usize,
        concat!("Size of: ", stringify!(filament_backend_RenderPassFlags))
    );
    assert_eq!(
        ::std::mem::align_of::<filament_backend_RenderPassFlags>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(filament_backend_RenderPassFlags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_backend_RenderPassFlags>())).clear as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_backend_RenderPassFlags),
            "::",
            stringify!(clear)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_backend_RenderPassFlags>())).discardStart as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_backend_RenderPassFlags),
            "::",
            stringify!(discardStart)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_backend_RenderPassFlags>())).discardEnd as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_backend_RenderPassFlags),
            "::",
            stringify!(discardEnd)
        )
    );
}
#[doc = " Parameters of a render pass."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct filament_backend_RenderPassParams {
    #[doc = "!< operations performed on the buffers for this pass"]
    pub flags: filament_backend_RenderPassFlags,
    #[doc = "!< viewport for this pass"]
    pub viewport: filament_backend_Viewport,
    #[doc = "! Color to use to clear the COLOR buffer. RenderPassFlags::clear must be set."]
    pub clearColor: filament_math_float4,
    #[doc = "! Depth value to clear the depth buffer with"]
    pub clearDepth: f64,
    #[doc = "! Stencil value to clear the stencil buffer with"]
    pub clearStencil: u32,
    #[doc = "! reserved, must be zero"]
    pub reserved1: u32,
}
#[test]
fn bindgen_test_layout_filament_backend_RenderPassParams() {
    assert_eq!(
        ::std::mem::size_of::<filament_backend_RenderPassParams>(),
        56usize,
        concat!("Size of: ", stringify!(filament_backend_RenderPassParams))
    );
    assert_eq!(
        ::std::mem::align_of::<filament_backend_RenderPassParams>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(filament_backend_RenderPassParams)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_backend_RenderPassParams>())).flags as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_backend_RenderPassParams),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_backend_RenderPassParams>())).viewport as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_backend_RenderPassParams),
            "::",
            stringify!(viewport)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_backend_RenderPassParams>())).clearColor as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_backend_RenderPassParams),
            "::",
            stringify!(clearColor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_backend_RenderPassParams>())).clearDepth as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_backend_RenderPassParams),
            "::",
            stringify!(clearDepth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_backend_RenderPassParams>())).clearStencil as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_backend_RenderPassParams),
            "::",
            stringify!(clearStencil)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_backend_RenderPassParams>())).reserved1 as *const _
                as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_backend_RenderPassParams),
            "::",
            stringify!(reserved1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct filament_backend_PolygonOffset {
    pub slope: f32,
    pub constant: f32,
}
#[test]
fn bindgen_test_layout_filament_backend_PolygonOffset() {
    assert_eq!(
        ::std::mem::size_of::<filament_backend_PolygonOffset>(),
        8usize,
        concat!("Size of: ", stringify!(filament_backend_PolygonOffset))
    );
    assert_eq!(
        ::std::mem::align_of::<filament_backend_PolygonOffset>(),
        4usize,
        concat!("Alignment of ", stringify!(filament_backend_PolygonOffset))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_backend_PolygonOffset>())).slope as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_backend_PolygonOffset),
            "::",
            stringify!(slope)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_backend_PolygonOffset>())).constant as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_backend_PolygonOffset),
            "::",
            stringify!(constant)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct filament_backend_Driver {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct filament_backend_Platform__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct filament_backend_Platform {
    pub vtable_: *const filament_backend_Platform__bindgen_vtable,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct filament_backend_Platform_SwapChain {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_filament_backend_Platform_SwapChain() {
    assert_eq!(
        ::std::mem::size_of::<filament_backend_Platform_SwapChain>(),
        1usize,
        concat!("Size of: ", stringify!(filament_backend_Platform_SwapChain))
    );
    assert_eq!(
        ::std::mem::align_of::<filament_backend_Platform_SwapChain>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(filament_backend_Platform_SwapChain)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct filament_backend_Platform_Fence {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_filament_backend_Platform_Fence() {
    assert_eq!(
        ::std::mem::size_of::<filament_backend_Platform_Fence>(),
        1usize,
        concat!("Size of: ", stringify!(filament_backend_Platform_Fence))
    );
    assert_eq!(
        ::std::mem::align_of::<filament_backend_Platform_Fence>(),
        1usize,
        concat!("Alignment of ", stringify!(filament_backend_Platform_Fence))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct filament_backend_Platform_Stream {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_filament_backend_Platform_Stream() {
    assert_eq!(
        ::std::mem::size_of::<filament_backend_Platform_Stream>(),
        1usize,
        concat!("Size of: ", stringify!(filament_backend_Platform_Stream))
    );
    assert_eq!(
        ::std::mem::align_of::<filament_backend_Platform_Stream>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(filament_backend_Platform_Stream)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct filament_backend_Platform_ExternalTexture {
    pub image: usize,
}
#[test]
fn bindgen_test_layout_filament_backend_Platform_ExternalTexture() {
    assert_eq!(
        ::std::mem::size_of::<filament_backend_Platform_ExternalTexture>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(filament_backend_Platform_ExternalTexture)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<filament_backend_Platform_ExternalTexture>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(filament_backend_Platform_ExternalTexture)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_backend_Platform_ExternalTexture>())).image as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_backend_Platform_ExternalTexture),
            "::",
            stringify!(image)
        )
    );
}
#[test]
fn bindgen_test_layout_filament_backend_Platform() {
    assert_eq!(
        ::std::mem::size_of::<filament_backend_Platform>(),
        8usize,
        concat!("Size of: ", stringify!(filament_backend_Platform))
    );
    assert_eq!(
        ::std::mem::align_of::<filament_backend_Platform>(),
        8usize,
        concat!("Alignment of ", stringify!(filament_backend_Platform))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8filament7backend8PlatformD1Ev"]
    pub fn filament_backend_Platform_Platform_destructor(this: *mut filament_backend_Platform);
}
#[repr(C)]
#[derive(Debug)]
pub struct filament_backend_DefaultPlatform {
    pub _base: filament_backend_Platform,
}
#[test]
fn bindgen_test_layout_filament_backend_DefaultPlatform() {
    assert_eq!(
        ::std::mem::size_of::<filament_backend_DefaultPlatform>(),
        8usize,
        concat!("Size of: ", stringify!(filament_backend_DefaultPlatform))
    );
    assert_eq!(
        ::std::mem::align_of::<filament_backend_DefaultPlatform>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(filament_backend_DefaultPlatform)
        )
    );
}
extern "C" {
    #[doc = " Creates a Platform configured for the requested backend if available"]
    #[doc = ""]
    #[doc = " @param backendHint Preferred backend, if not available the backend most suitable for the"]
    #[doc = "                    underlying platform is returned and \\p backendHint is updated"]
    #[doc = "                    accordingly. Can't be nullptr."]
    #[doc = ""]
    #[doc = " @return A pointer to the Plaform object."]
    #[doc = ""]
    #[doc = " @see destroy"]
    #[link_name = "\u{1}_ZN8filament7backend15DefaultPlatform6createEPNS0_7BackendE"]
    pub fn filament_backend_DefaultPlatform_create(
        backendHint: *mut filament_backend_Backend,
    ) -> *mut filament_backend_DefaultPlatform;
}
extern "C" {
    #[doc = " Destroys a Platform object returned by create()"]
    #[doc = ""]
    #[doc = " @param platform a reference (as a pointer) to the DefaultPlatform pointer to destroy."]
    #[doc = "                 \\p platform is cleared upon return."]
    #[doc = ""]
    #[doc = " @see create"]
    #[link_name = "\u{1}_ZN8filament7backend15DefaultPlatform7destroyEPPS1_"]
    pub fn filament_backend_DefaultPlatform_destroy(
        platform: *mut *mut filament_backend_DefaultPlatform,
    );
}
impl filament_backend_DefaultPlatform {
    #[inline]
    pub unsafe fn create(
        backendHint: *mut filament_backend_Backend,
    ) -> *mut filament_backend_DefaultPlatform {
        filament_backend_DefaultPlatform_create(backendHint)
    }
    #[inline]
    pub unsafe fn destroy(platform: *mut *mut filament_backend_DefaultPlatform) {
        filament_backend_DefaultPlatform_destroy(platform)
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN8filament7backend15DefaultPlatformD1Ev"]
    pub fn filament_backend_DefaultPlatform_DefaultPlatform_destructor(
        this: *mut filament_backend_DefaultPlatform,
    );
}
#[doc = " A PresentCallable is a callable object that, when called, schedules a frame for presentation on"]
#[doc = " a SwapChain."]
#[doc = ""]
#[doc = " Typically, Filament's backend is responsible scheduling a frame's presentation. However, there"]
#[doc = " are certain cases where the application might want to control when a frame is scheduled for"]
#[doc = " presentation."]
#[doc = ""]
#[doc = " For example, on iOS, UIKit elements can be synchronized to 3D content by scheduling a present"]
#[doc = " within a CATransation:"]
#[doc = ""]
#[doc = " ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"]
#[doc = " void myFrameFinishedCallback(PresentCallable presentCallable, void* user) {"]
#[doc = "     [CATransaction begin];"]
#[doc = "     // Update other UI elements..."]
#[doc = "     presentCallable();"]
#[doc = "     [CATransaction commit];"]
#[doc = " }"]
#[doc = " ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"]
#[doc = ""]
#[doc = " To obtain a PresentCallable, pass a backend::FrameFinishedCallback to the beginFrame() function."]
#[doc = " The callback is called with a PresentCallable object and optional user data:"]
#[doc = ""]
#[doc = " ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"]
#[doc = " if (renderer->beginFrame(swapChain, myFrameFinishedCallback, nullptr)) {"]
#[doc = "     renderer->render(view);"]
#[doc = "     renderer->endFrame();"]
#[doc = " }"]
#[doc = " ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"]
#[doc = ""]
#[doc = " @remark Only Filament's Metal backend supports PresentCallables and frame callbacks. Other"]
#[doc = " backends ignore the callback (which will never be called) and proceed normally."]
#[doc = ""]
#[doc = " @remark The backend::FrameFinishedCallback is called on an arbitrary thread."]
#[doc = ""]
#[doc = " Applications *must* call each PresentCallable they receive. Each PresentCallable represents a"]
#[doc = " frame that is waiting to be presented. If an application fails to call a PresentCallable, a"]
#[doc = " memory leak could occur. To \"cancel\" the presentation of a frame, pass false to the"]
#[doc = " PresentCallable, which will cancel the presentation of the frame and release associated memory."]
#[doc = ""]
#[doc = " @see Renderer, SwapChain, Renderer.beginFrame"]
#[repr(C)]
#[derive(Debug)]
pub struct filament_backend_PresentCallable {
    pub mPresentFn: filament_backend_PresentCallable_PresentFn,
    pub mUser: *mut ::std::os::raw::c_void,
}
pub type filament_backend_PresentCallable_PresentFn = ::std::option::Option<
    unsafe extern "C" fn(presentFrame: bool, user: *mut ::std::os::raw::c_void),
>;
#[test]
fn bindgen_test_layout_filament_backend_PresentCallable() {
    assert_eq!(
        ::std::mem::size_of::<filament_backend_PresentCallable>(),
        16usize,
        concat!("Size of: ", stringify!(filament_backend_PresentCallable))
    );
    assert_eq!(
        ::std::mem::align_of::<filament_backend_PresentCallable>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(filament_backend_PresentCallable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_backend_PresentCallable>())).mPresentFn as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_backend_PresentCallable),
            "::",
            stringify!(mPresentFn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_backend_PresentCallable>())).mUser as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_backend_PresentCallable),
            "::",
            stringify!(mUser)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8filament7backend15PresentCallableC1EPFvbPvES2_"]
    pub fn filament_backend_PresentCallable_PresentCallable(
        this: *mut filament_backend_PresentCallable,
        fn_: filament_backend_PresentCallable_PresentFn,
        user: *mut ::std::os::raw::c_void,
    );
}
impl filament_backend_PresentCallable {
    #[inline]
    pub unsafe fn new(
        fn_: filament_backend_PresentCallable_PresentFn,
        user: *mut ::std::os::raw::c_void,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        filament_backend_PresentCallable_PresentCallable(__bindgen_tmp.as_mut_ptr(), fn_, user);
        __bindgen_tmp.assume_init()
    }
}
#[doc = " FrameFinishedCallback is a callback function that notifies an application when Filament has"]
#[doc = " finished processing a frame and that frame is ready to be scheduled for presentation."]
#[doc = ""]
#[doc = " beginFrame() takes an optional FrameFinishedCallback. If the callback is provided, then that"]
#[doc = " frame will *not* automatically be scheduled for presentation. Instead, the application must call"]
#[doc = " the given PresentCallable."]
#[doc = ""]
#[doc = " @remark The backend::FrameFinishedCallback is called on an arbitrary thread."]
#[doc = ""]
#[doc = " @see PresentCallable, beginFrame()"]
pub type filament_backend_FrameFinishedCallback = ::std::option::Option<
    unsafe extern "C" fn(
        callable: filament_backend_PresentCallable,
        user: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " A CPU memory-buffer descriptor, typically used to transfer data from the CPU to the GPU."]
#[doc = ""]
#[doc = " A BufferDescriptor owns the memory buffer it references, therefore BufferDescriptor cannot"]
#[doc = " be copied, but can be moved."]
#[doc = ""]
#[doc = " BufferDescriptor releases ownership of the memory-buffer when it's destroyed."]
#[repr(C)]
#[derive(Debug)]
pub struct filament_backend_BufferDescriptor {
    #[doc = "! CPU mempry-buffer virtual address"]
    pub buffer: *mut ::std::os::raw::c_void,
    #[doc = "! CPU memory-buffer size in bytes"]
    pub size: size_t,
    pub callback: filament_backend_BufferDescriptor_Callback,
    pub user: *mut ::std::os::raw::c_void,
}
#[doc = " Callback used to destroy the buffer data."]
#[doc = " Guarantees:"]
#[doc = "      Called on the main filament thread."]
#[doc = ""]
#[doc = " Limitations:"]
#[doc = "      Must be lightweight."]
#[doc = "      Must not call filament APIs."]
pub type filament_backend_BufferDescriptor_Callback = ::std::option::Option<
    unsafe extern "C" fn(
        buffer: *mut ::std::os::raw::c_void,
        size: size_t,
        user: *mut ::std::os::raw::c_void,
    ),
>;
#[test]
fn bindgen_test_layout_filament_backend_BufferDescriptor() {
    assert_eq!(
        ::std::mem::size_of::<filament_backend_BufferDescriptor>(),
        32usize,
        concat!("Size of: ", stringify!(filament_backend_BufferDescriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<filament_backend_BufferDescriptor>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(filament_backend_BufferDescriptor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_backend_BufferDescriptor>())).buffer as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_backend_BufferDescriptor),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_backend_BufferDescriptor>())).size as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_backend_BufferDescriptor),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_backend_BufferDescriptor>())).callback as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_backend_BufferDescriptor),
            "::",
            stringify!(callback)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_backend_BufferDescriptor>())).user as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_backend_BufferDescriptor),
            "::",
            stringify!(user)
        )
    );
}
#[doc = " A descriptor to an image in main memory, typically used to transfer image data from the CPU"]
#[doc = " to the GPU."]
#[doc = ""]
#[doc = " A PixelBufferDescriptor owns the memory buffer it references, therefore PixelBufferDescriptor"]
#[doc = " cannot be copied, but can be moved."]
#[doc = ""]
#[doc = " PixelBufferDescriptor releases ownership of the memory-buffer when it's destroyed."]
#[repr(C)]
#[derive(Debug)]
pub struct filament_backend_PixelBufferDescriptor {
    pub _base: filament_backend_BufferDescriptor,
    #[doc = "! left coordinate in pixels"]
    pub left: u32,
    #[doc = "! top coordinate in pixels"]
    pub top: u32,
    pub __bindgen_anon_1: filament_backend_PixelBufferDescriptor__bindgen_ty_1,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 7usize],
}
pub use self::filament_backend_PixelDataFormat as filament_backend_PixelBufferDescriptor_PixelDataFormat;
pub use self::filament_backend_PixelDataType as filament_backend_PixelBufferDescriptor_PixelDataType;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct filament_backend_PixelBufferDescriptor__bindgen_ty_1 {
    pub __bindgen_anon_1:
        __BindgenUnionField<filament_backend_PixelBufferDescriptor__bindgen_ty_1__bindgen_ty_1>,
    pub __bindgen_anon_2:
        __BindgenUnionField<filament_backend_PixelBufferDescriptor__bindgen_ty_1__bindgen_ty_2>,
    pub bindgen_union_field: [u32; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct filament_backend_PixelBufferDescriptor__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "! stride in pixels"]
    pub stride: u32,
    #[doc = "! Pixel data format"]
    pub format: filament_backend_PixelBufferDescriptor_PixelDataFormat,
}
#[test]
fn bindgen_test_layout_filament_backend_PixelBufferDescriptor__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<filament_backend_PixelBufferDescriptor__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(filament_backend_PixelBufferDescriptor__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<filament_backend_PixelBufferDescriptor__bindgen_ty_1__bindgen_ty_1>(
        ),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(filament_backend_PixelBufferDescriptor__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                filament_backend_PixelBufferDescriptor__bindgen_ty_1__bindgen_ty_1,
            >()))
            .stride as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_backend_PixelBufferDescriptor__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(stride)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                filament_backend_PixelBufferDescriptor__bindgen_ty_1__bindgen_ty_1,
            >()))
            .format as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_backend_PixelBufferDescriptor__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(format)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct filament_backend_PixelBufferDescriptor__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "! compressed image size"]
    pub imageSize: u32,
    #[doc = "! compressed image format"]
    pub compressedFormat: filament_backend_CompressedPixelDataType,
}
#[test]
fn bindgen_test_layout_filament_backend_PixelBufferDescriptor__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<filament_backend_PixelBufferDescriptor__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(filament_backend_PixelBufferDescriptor__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<filament_backend_PixelBufferDescriptor__bindgen_ty_1__bindgen_ty_2>(
        ),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(filament_backend_PixelBufferDescriptor__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                filament_backend_PixelBufferDescriptor__bindgen_ty_1__bindgen_ty_2,
            >()))
            .imageSize as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_backend_PixelBufferDescriptor__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(imageSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                filament_backend_PixelBufferDescriptor__bindgen_ty_1__bindgen_ty_2,
            >()))
            .compressedFormat as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_backend_PixelBufferDescriptor__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(compressedFormat)
        )
    );
}
#[test]
fn bindgen_test_layout_filament_backend_PixelBufferDescriptor__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<filament_backend_PixelBufferDescriptor__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(filament_backend_PixelBufferDescriptor__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<filament_backend_PixelBufferDescriptor__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(filament_backend_PixelBufferDescriptor__bindgen_ty_1)
        )
    );
}
#[test]
fn bindgen_test_layout_filament_backend_PixelBufferDescriptor() {
    assert_eq!(
        ::std::mem::size_of::<filament_backend_PixelBufferDescriptor>(),
        56usize,
        concat!(
            "Size of: ",
            stringify!(filament_backend_PixelBufferDescriptor)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<filament_backend_PixelBufferDescriptor>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(filament_backend_PixelBufferDescriptor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_backend_PixelBufferDescriptor>())).left as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_backend_PixelBufferDescriptor),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_backend_PixelBufferDescriptor>())).top as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_backend_PixelBufferDescriptor),
            "::",
            stringify!(top)
        )
    );
}
impl filament_backend_PixelBufferDescriptor {
    #[inline]
    pub fn type_(&self) -> filament_backend_PixelBufferDescriptor_PixelDataType {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_type(&mut self, val: filament_backend_PixelBufferDescriptor_PixelDataType) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn alignment(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_alignment(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        type_: filament_backend_PixelBufferDescriptor_PixelDataType,
        alignment: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let type_: u8 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let alignment: u8 = unsafe { ::std::mem::transmute(alignment) };
            alignment as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct filament_DebugRegistry {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct filament_Fence {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct filament_IndirectLight {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct filament_Material {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct filament_MaterialInstance {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct filament_RenderTarget {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct filament_Skybox {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct filament_Stream {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct filament_LightManager {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct filament_RenderableManager {
    _unused: [u8; 0],
}
#[doc = " Engine is filament's main entry-point."]
#[doc = ""]
#[doc = " An Engine instance main function is to keep track of all resources created by the user and"]
#[doc = " manage the rendering thread as well as the hardware renderer."]
#[doc = ""]
#[doc = " To use filament, an Engine instance must be created first:"]
#[doc = ""]
#[doc = " ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"]
#[doc = " #include <filament/Engine.h>"]
#[doc = " using namespace filament;"]
#[doc = ""]
#[doc = " Engine* engine = Engine::create();"]
#[doc = " ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"]
#[doc = ""]
#[doc = " Engine essentially represents (or is associated to) a hardware context"]
#[doc = " (e.g. an OpenGL ES context)."]
#[doc = ""]
#[doc = " Rendering typically happens in an operating system's window (which can be full screen), such"]
#[doc = " window is managed by a filament.Renderer."]
#[doc = ""]
#[doc = " A typical filament render loop looks like this:"]
#[doc = ""]
#[doc = ""]
#[doc = " ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"]
#[doc = " #include <filament/Engine.h>"]
#[doc = " #include <filament/Renderer.h>"]
#[doc = " #include <filament/Scene.h>"]
#[doc = " #include <filament/View.h>"]
#[doc = " using namespace filament;"]
#[doc = ""]
#[doc = " Engine* engine       = Engine::create();"]
#[doc = " SwapChain* swapChain = engine->createSwapChain(nativeWindow);"]
#[doc = " Renderer* renderer   = engine->createRenderer();"]
#[doc = " Scene* scene         = engine->createScene();"]
#[doc = " View* view           = engine->createView();"]
#[doc = ""]
#[doc = " view->setScene(scene);"]
#[doc = ""]
#[doc = " do {"]
#[doc = "     // typically we wait for VSYNC and user input events"]
#[doc = "     if (renderer->beginFrame(swapChain)) {"]
#[doc = "         renderer->render(view);"]
#[doc = "         renderer->endFrame();"]
#[doc = "     }"]
#[doc = " } while (!quit);"]
#[doc = ""]
#[doc = " engine->destroy(view);"]
#[doc = " engine->destroy(scene);"]
#[doc = " engine->destroy(renderer);"]
#[doc = " engine->destroy(swapChain);"]
#[doc = " Engine::destroy(&engine); // clears engine*"]
#[doc = " ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"]
#[doc = ""]
#[doc = " Resource Tracking"]
#[doc = " ================="]
#[doc = ""]
#[doc = "  Each Engine instance keeps track of all objects created by the user, such as vertex and index"]
#[doc = "  buffers, lights, cameras, etc..."]
#[doc = "  The user is expected to free those resources, however, leaked resources are freed when the"]
#[doc = "  engine instance is destroyed and a warning is emitted in the console."]
#[doc = ""]
#[doc = " Thread safety"]
#[doc = " ============="]
#[doc = ""]
#[doc = " An Engine instance is not thread-safe. The implementation makes no attempt to synchronize"]
#[doc = " calls to an Engine instance methods."]
#[doc = " If multi-threading is needed, synchronization must be external."]
#[doc = ""]
#[doc = " Multi-threading"]
#[doc = " ==============="]
#[doc = ""]
#[doc = " When created, the Engine instance starts a render thread as well as multiple worker threads,"]
#[doc = " these threads have an elevated priority appropriate for rendering, based on the platform's"]
#[doc = " best practices. The number of worker threads depends on the platform and is automatically"]
#[doc = " chosen for best performance."]
#[doc = ""]
#[doc = " On platforms with asymmetric cores (e.g. ARM's Big.Little), Engine makes some educated guesses"]
#[doc = " as to which cores to use for the render thread and worker threads. For example, it'll try to"]
#[doc = " keep an OpenGL ES thread on a Big core."]
#[doc = ""]
#[doc = " Swap Chains"]
#[doc = " ==========="]
#[doc = ""]
#[doc = " A swap chain represents an Operating System's *native* renderable surface. Typically it's a window"]
#[doc = " or a view. Because a SwapChain is initialized from a native object, it is given to filament"]
#[doc = " as a `void*`, which must be of the proper type for each platform filament is running on."]
#[doc = ""]
#[doc = " @see SwapChain"]
#[doc = ""]
#[doc = ""]
#[doc = " @see Renderer"]
#[repr(C)]
#[derive(Debug)]
pub struct filament_Engine {
    pub _address: u8,
}
pub type filament_Engine_Platform = filament_backend_Platform;
pub use self::filament_backend_Backend as filament_Engine_Backend;
#[test]
fn bindgen_test_layout_filament_Engine() {
    assert_eq!(
        ::std::mem::size_of::<filament_Engine>(),
        1usize,
        concat!("Size of: ", stringify!(filament_Engine))
    );
    assert_eq!(
        ::std::mem::align_of::<filament_Engine>(),
        1usize,
        concat!("Alignment of ", stringify!(filament_Engine))
    );
}
extern "C" {
    #[doc = " Creates an instance of Engine"]
    #[doc = ""]
    #[doc = " @param backend           Which driver backend to use."]
    #[doc = ""]
    #[doc = " @param platform          A pointer to an object that implements Platform. If this is"]
    #[doc = "                          provided, then this object is used to create the hardware context"]
    #[doc = "                          and expose platform features to it."]
    #[doc = ""]
    #[doc = "                          If not provided (or nullptr is used), an appropriate Platform"]
    #[doc = "                          is created automatically."]
    #[doc = ""]
    #[doc = "                          All methods of this interface are called from filament's"]
    #[doc = "                          render thread, which is different from the main thread."]
    #[doc = ""]
    #[doc = "                          The lifetime of \\p platform must exceed the lifetime of"]
    #[doc = "                          the Engine object."]
    #[doc = ""]
    #[doc = "  @param sharedGLContext  A platform-dependant OpenGL context used as a shared context"]
    #[doc = "                          when creating filament's internal context."]
    #[doc = "                          Setting this parameter will force filament to use the OpenGL"]
    #[doc = "                          implementation (instead of Vulkan for instance)."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @return A pointer to the newly created Engine, or nullptr if the Engine couldn't be created."]
    #[doc = ""]
    #[doc = " nullptr if the GPU driver couldn't be initialized, for instance if it doesn't"]
    #[doc = " support the right version of OpenGL or OpenGL ES."]
    #[doc = ""]
    #[doc = " @exception utils::PostConditionPanic can be thrown if there isn't enough memory to"]
    #[doc = " allocate the command buffer. If exceptions are disabled, this condition if fatal and"]
    #[doc = " this function will abort."]
    #[doc = ""]
    #[doc = " \\remark"]
    #[doc = " This method is thread-safe."]
    #[link_name = "\u{1}_ZN8filament6Engine6createENS_7backend7BackendEPNS1_8PlatformEPv"]
    pub fn filament_Engine_create(
        backend: filament_Engine_Backend,
        platform: *mut filament_Engine_Platform,
        sharedGLContext: *mut ::std::os::raw::c_void,
    ) -> *mut filament_Engine;
}
extern "C" {
    #[doc = " Destroy the Engine instance and all associated resources."]
    #[doc = ""]
    #[doc = " Engine.destroy() should be called last and after all other resources have been destroyed,"]
    #[doc = " it ensures all filament resources are freed."]
    #[doc = ""]
    #[doc = " Destroy performs the following tasks:"]
    #[doc = " 1. Destroy all internal software and hardware resources."]
    #[doc = " 2. Free all user allocated resources that are not already destroyed and logs a warning."]
    #[doc = "    This indicates a \"leak\" in the user's code."]
    #[doc = " 3. Terminate the rendering engine's thread."]
    #[doc = ""]
    #[doc = " @param engine A pointer to the filament.Engine* to be destroyed."]
    #[doc = "               \\p engine is cleared upon return."]
    #[doc = ""]
    #[doc = " ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"]
    #[doc = " #include <filament/Engine.h>"]
    #[doc = " using namespace filament;"]
    #[doc = ""]
    #[doc = " Engine* engine = Engine::create();"]
    #[doc = " Engine::destroy(&engine); // clears engine*"]
    #[doc = " ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"]
    #[doc = ""]
    #[doc = " \\remark"]
    #[doc = " This method is thread-safe."]
    #[link_name = "\u{1}_ZN8filament6Engine7destroyEPPS0_"]
    pub fn filament_Engine_destroy(engine: *mut *mut filament_Engine);
}
extern "C" {
    #[doc = " Destroy the Engine instance and all associated resources."]
    #[doc = ""]
    #[doc = " Engine.destroy() should be called last and after all other resources have been destroyed,"]
    #[doc = " it ensures all filament resources are freed."]
    #[doc = ""]
    #[doc = " Destroy performs the following tasks:"]
    #[doc = " 1. Destroy all internal software and hardware resources."]
    #[doc = " 2. Free all user allocated resources that are not already destroyed and logs a warning."]
    #[doc = "    This indicates a \"leak\" in the user's code."]
    #[doc = " 3. Terminate the rendering engine's thread."]
    #[doc = ""]
    #[doc = " @param engine A pointer to the filament.Engine to be destroyed."]
    #[doc = ""]
    #[doc = " ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"]
    #[doc = " #include <filament/Engine.h>"]
    #[doc = " using namespace filament;"]
    #[doc = ""]
    #[doc = " Engine* engine = Engine::create();"]
    #[doc = " Engine::destroy(engine);"]
    #[doc = " ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"]
    #[doc = ""]
    #[doc = " \\remark"]
    #[doc = " This method is thread-safe."]
    #[link_name = "\u{1}_ZN8filament6Engine7destroyEPS0_"]
    pub fn filament_Engine_destroy1(engine: *mut filament_Engine);
}
extern "C" {
    #[link_name = "\u{1}_ZN8filament6Engine20getRenderableManagerEv"]
    pub fn filament_Engine_getRenderableManager(
        this: *mut filament_Engine,
    ) -> *mut filament_RenderableManager;
}
extern "C" {
    #[link_name = "\u{1}_ZN8filament6Engine15getLightManagerEv"]
    pub fn filament_Engine_getLightManager(
        this: *mut filament_Engine,
    ) -> *mut filament_LightManager;
}
extern "C" {
    #[link_name = "\u{1}_ZN8filament6Engine19getTransformManagerEv"]
    pub fn filament_Engine_getTransformManager(
        this: *mut filament_Engine,
    ) -> *mut filament_TransformManager;
}
extern "C" {
    #[doc = " Creates a SwapChain from the given Operating System's native window handle."]
    #[doc = ""]
    #[doc = " @param nativeWindow An opaque native window handle. e.g.: on Android this is an"]
    #[doc = "                     `ANativeWindow*`."]
    #[doc = " @param flags One or more configuration flags as defined in `SwapChain`."]
    #[doc = ""]
    #[doc = " @return A pointer to the newly created SwapChain or nullptr if it couldn't be created."]
    #[doc = ""]
    #[doc = " @see Renderer.beginFrame()"]
    #[link_name = "\u{1}_ZN8filament6Engine15createSwapChainEPvm"]
    pub fn filament_Engine_createSwapChain(
        this: *mut filament_Engine,
        nativeWindow: *mut ::std::os::raw::c_void,
        flags: u64,
    ) -> *mut filament_SwapChain;
}
extern "C" {
    #[doc = " Creates a headless SwapChain."]
    #[doc = ""]
    #[doc = " @param width    Width of the drawing buffer in pixels."]
    #[doc = " @param height   Height of the drawing buffer in pixels."]
    #[doc = " @param flags     One or more configuration flags as defined in `SwapChain`."]
    #[doc = ""]
    #[doc = " @return A pointer to the newly created SwapChain or nullptr if it couldn't be created."]
    #[doc = ""]
    #[doc = " @see Renderer.beginFrame()"]
    #[link_name = "\u{1}_ZN8filament6Engine15createSwapChainEjjm"]
    pub fn filament_Engine_createSwapChain1(
        this: *mut filament_Engine,
        width: u32,
        height: u32,
        flags: u64,
    ) -> *mut filament_SwapChain;
}
extern "C" {
    #[doc = " Creates a renderer associated to this engine."]
    #[doc = ""]
    #[doc = " A Renderer is intended to map to a *window* on screen."]
    #[doc = ""]
    #[doc = " @return A pointer to the newly created Renderer or nullptr if it couldn't be created."]
    #[link_name = "\u{1}_ZN8filament6Engine14createRendererEv"]
    pub fn filament_Engine_createRenderer(this: *mut filament_Engine) -> *mut filament_Renderer;
}
extern "C" {
    #[doc = " Creates a View."]
    #[doc = ""]
    #[doc = " @return A pointer to the newly created View or nullptr if it couldn't be created."]
    #[link_name = "\u{1}_ZN8filament6Engine10createViewEv"]
    pub fn filament_Engine_createView(this: *mut filament_Engine) -> *mut filament_View;
}
extern "C" {
    #[doc = " Creates a Scene."]
    #[doc = ""]
    #[doc = " @return A pointer to the newly created Scene or nullptr if it couldn't be created."]
    #[link_name = "\u{1}_ZN8filament6Engine11createSceneEv"]
    pub fn filament_Engine_createScene(this: *mut filament_Engine) -> *mut filament_Scene;
}
extern "C" {
    #[doc = " Creates a Camera component."]
    #[doc = ""]
    #[doc = " @param entity Entity to add the camera component to."]
    #[doc = " @return A pointer to the newly created Camera or nullptr if it couldn't be created."]
    #[link_name = "\u{1}_ZN8filament6Engine12createCameraEN5utils6EntityE"]
    pub fn filament_Engine_createCamera(
        this: *mut filament_Engine,
        entity: utils_Entity,
    ) -> *mut filament_Camera;
}
extern "C" {
    #[doc = " Returns the Camera component of the given its entity."]
    #[doc = ""]
    #[doc = " @param entity An entity."]
    #[doc = " @return A pointer to the Camera component for this entity or nullptr if the entity didn't"]
    #[doc = "         have a Camera component. The pointer is valid until destroyCameraComponent()"]
    #[doc = "         (or destroyCamera()) is called or the entity itself is destroyed."]
    #[link_name = "\u{1}_ZN8filament6Engine18getCameraComponentEN5utils6EntityE"]
    pub fn filament_Engine_getCameraComponent(
        this: *mut filament_Engine,
        entity: utils_Entity,
    ) -> *mut filament_Camera;
}
extern "C" {
    #[doc = " Destroys the Camera component associated with the given entity."]
    #[doc = ""]
    #[doc = " @param entity An entity."]
    #[link_name = "\u{1}_ZN8filament6Engine22destroyCameraComponentEN5utils6EntityE"]
    pub fn filament_Engine_destroyCameraComponent(this: *mut filament_Engine, entity: utils_Entity);
}
extern "C" {
    #[doc = " Creates a Fence."]
    #[doc = ""]
    #[doc = " @return A pointer to the newly created Fence or nullptr if it couldn't be created."]
    #[link_name = "\u{1}_ZN8filament6Engine11createFenceEv"]
    pub fn filament_Engine_createFence(this: *mut filament_Engine) -> *mut filament_Fence;
}
extern "C" {
    #[link_name = "\u{1}_ZN8filament6Engine7destroyEPKNS_12VertexBufferE"]
    pub fn filament_Engine_destroy2(this: *mut filament_Engine, p: *const filament_VertexBuffer);
}
extern "C" {
    #[link_name = "\u{1}_ZN8filament6Engine7destroyEPKNS_5FenceE"]
    pub fn filament_Engine_destroy3(this: *mut filament_Engine, p: *const filament_Fence);
}
extern "C" {
    #[link_name = "\u{1}_ZN8filament6Engine7destroyEPKNS_11IndexBufferE"]
    pub fn filament_Engine_destroy4(this: *mut filament_Engine, p: *const filament_IndexBuffer);
}
extern "C" {
    #[link_name = "\u{1}_ZN8filament6Engine7destroyEPKNS_13IndirectLightE"]
    pub fn filament_Engine_destroy5(this: *mut filament_Engine, p: *const filament_IndirectLight);
}
extern "C" {
    #[doc = " Destroys a Material object"]
    #[doc = " @param p the material object to destroy"]
    #[doc = " @attention All MaterialInstance of the specified material must be destroyed before"]
    #[doc = "            destroying it."]
    #[doc = " @exception utils::PreConditionPanic is thrown if some MaterialInstances remain."]
    #[doc = " no-op if exceptions are disabled and some MaterialInstances remain."]
    #[link_name = "\u{1}_ZN8filament6Engine7destroyEPKNS_8MaterialE"]
    pub fn filament_Engine_destroy6(this: *mut filament_Engine, p: *const filament_Material);
}
extern "C" {
    #[link_name = "\u{1}_ZN8filament6Engine7destroyEPKNS_16MaterialInstanceE"]
    pub fn filament_Engine_destroy7(
        this: *mut filament_Engine,
        p: *const filament_MaterialInstance,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8filament6Engine7destroyEPKNS_8RendererE"]
    pub fn filament_Engine_destroy8(this: *mut filament_Engine, p: *const filament_Renderer);
}
extern "C" {
    #[link_name = "\u{1}_ZN8filament6Engine7destroyEPKNS_5SceneE"]
    pub fn filament_Engine_destroy9(this: *mut filament_Engine, p: *const filament_Scene);
}
extern "C" {
    #[link_name = "\u{1}_ZN8filament6Engine7destroyEPKNS_6SkyboxE"]
    pub fn filament_Engine_destroy10(this: *mut filament_Engine, p: *const filament_Skybox);
}
extern "C" {
    #[link_name = "\u{1}_ZN8filament6Engine7destroyEPKNS_9SwapChainE"]
    pub fn filament_Engine_destroy11(this: *mut filament_Engine, p: *const filament_SwapChain);
}
extern "C" {
    #[link_name = "\u{1}_ZN8filament6Engine7destroyEPKNS_6StreamE"]
    pub fn filament_Engine_destroy12(this: *mut filament_Engine, p: *const filament_Stream);
}
extern "C" {
    #[link_name = "\u{1}_ZN8filament6Engine7destroyEPKNS_7TextureE"]
    pub fn filament_Engine_destroy13(this: *mut filament_Engine, p: *const filament_Texture);
}
extern "C" {
    #[link_name = "\u{1}_ZN8filament6Engine7destroyEPKNS_12RenderTargetE"]
    pub fn filament_Engine_destroy14(this: *mut filament_Engine, p: *const filament_RenderTarget);
}
extern "C" {
    #[link_name = "\u{1}_ZN8filament6Engine7destroyEPKNS_4ViewE"]
    pub fn filament_Engine_destroy15(this: *mut filament_Engine, p: *const filament_View);
}
extern "C" {
    #[link_name = "\u{1}_ZN8filament6Engine7destroyEN5utils6EntityE"]
    pub fn filament_Engine_destroy16(this: *mut filament_Engine, e: utils_Entity);
}
extern "C" {
    #[doc = " Kicks the hardware thread (e.g. the OpenGL, Vulkan or Metal thread) and blocks until"]
    #[doc = " all commands to this point are executed. Note that this doesn't guarantee that the"]
    #[doc = " hardware is actually finished."]
    #[doc = ""]
    #[doc = " <p>This is typically used right after destroying the <code>SwapChain</code>,"]
    #[doc = " in cases where a guarantee about the <code>SwapChain</code> destruction is needed in a"]
    #[doc = " timely fashion, such as when responding to Android's"]
    #[doc = " <code>android.view.SurfaceHolder.Callback.surfaceDestroyed</code></p>"]
    #[link_name = "\u{1}_ZN8filament6Engine12flushAndWaitEv"]
    pub fn filament_Engine_flushAndWait(this: *mut filament_Engine);
}
extern "C" {
    #[doc = " Returns the default Material."]
    #[doc = ""]
    #[doc = " The default material is 80% white and uses the Material.Shading.LIT shading."]
    #[doc = ""]
    #[doc = " @return A pointer to the default Material instance (a singleton)."]
    #[link_name = "\u{1}_ZNK8filament6Engine18getDefaultMaterialEv"]
    pub fn filament_Engine_getDefaultMaterial(
        this: *const filament_Engine,
    ) -> *const filament_Material;
}
extern "C" {
    #[doc = " Returns the resolved backend."]
    #[link_name = "\u{1}_ZNK8filament6Engine10getBackendEv"]
    pub fn filament_Engine_getBackend(this: *const filament_Engine) -> filament_Engine_Backend;
}
extern "C" {
    #[doc = " Allocate a small amount of memory directly in the command stream. The allocated memory is"]
    #[doc = " guaranteed to be preserved until the current command buffer is executed"]
    #[doc = ""]
    #[doc = " @param size       size to allocate in bytes. This should be small (e.g. < 1 KB)"]
    #[doc = " @param alignment  alignment requested"]
    #[doc = " @return           a pointer to the allocated buffer or nullptr if no memory was available."]
    #[doc = ""]
    #[doc = " @note there is no need to destroy this buffer, it will be freed automatically when"]
    #[doc = "       the current command buffer is executed."]
    #[link_name = "\u{1}_ZN8filament6Engine11streamAllocEmm"]
    pub fn filament_Engine_streamAlloc(
        this: *mut filament_Engine,
        size: size_t,
        alignment: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " helper for creating an Entity and Camera component in one call"]
    #[doc = ""]
    #[doc = " @return A camera component"]
    #[link_name = "\u{1}_ZN8filament6Engine12createCameraEv"]
    pub fn filament_Engine_createCamera1(this: *mut filament_Engine) -> *mut filament_Camera;
}
extern "C" {
    #[doc = " helper for destroying the Camera component and its Entity in one call"]
    #[doc = ""]
    #[doc = " @param camera Camera component to destroy. The associated entity as well as all its"]
    #[doc = "               components managed by filament are destroyed."]
    #[doc = " @deprecated use destroyCameraComponent(Entity) instead"]
    #[link_name = "\u{1}_ZN8filament6Engine7destroyEPKNS_6CameraE"]
    pub fn filament_Engine_destroy17(this: *mut filament_Engine, camera: *const filament_Camera);
}
extern "C" {
    #[doc = " Invokes one iteration of the render loop, used only on single-threaded platforms."]
    #[doc = ""]
    #[doc = " This should be called every time the windowing system needs to paint (e.g. at 60 Hz)."]
    #[link_name = "\u{1}_ZN8filament6Engine7executeEv"]
    pub fn filament_Engine_execute(this: *mut filament_Engine);
}
extern "C" {
    #[doc = " Retrieves the job system that the Engine has ownership over."]
    #[link_name = "\u{1}_ZN8filament6Engine12getJobSystemEv"]
    pub fn filament_Engine_getJobSystem(this: *mut filament_Engine) -> *mut utils_JobSystem;
}
extern "C" {
    #[link_name = "\u{1}_ZN8filament6Engine16getDebugRegistryEv"]
    pub fn filament_Engine_getDebugRegistry(
        this: *mut filament_Engine,
    ) -> *mut filament_DebugRegistry;
}
impl filament_Engine {
    #[inline]
    pub unsafe fn create(
        backend: filament_Engine_Backend,
        platform: *mut filament_Engine_Platform,
        sharedGLContext: *mut ::std::os::raw::c_void,
    ) -> *mut filament_Engine {
        filament_Engine_create(backend, platform, sharedGLContext)
    }
    #[inline]
    pub unsafe fn destroy(engine: *mut *mut filament_Engine) {
        filament_Engine_destroy(engine)
    }
    #[inline]
    pub unsafe fn destroy1(engine: *mut filament_Engine) {
        filament_Engine_destroy1(engine)
    }
    #[inline]
    pub unsafe fn getRenderableManager(&mut self) -> *mut filament_RenderableManager {
        filament_Engine_getRenderableManager(self)
    }
    #[inline]
    pub unsafe fn getLightManager(&mut self) -> *mut filament_LightManager {
        filament_Engine_getLightManager(self)
    }
    #[inline]
    pub unsafe fn getTransformManager(&mut self) -> *mut filament_TransformManager {
        filament_Engine_getTransformManager(self)
    }
    #[inline]
    pub unsafe fn createSwapChain(
        &mut self,
        nativeWindow: *mut ::std::os::raw::c_void,
        flags: u64,
    ) -> *mut filament_SwapChain {
        filament_Engine_createSwapChain(self, nativeWindow, flags)
    }
    #[inline]
    pub unsafe fn createSwapChain1(
        &mut self,
        width: u32,
        height: u32,
        flags: u64,
    ) -> *mut filament_SwapChain {
        filament_Engine_createSwapChain1(self, width, height, flags)
    }
    #[inline]
    pub unsafe fn createRenderer(&mut self) -> *mut filament_Renderer {
        filament_Engine_createRenderer(self)
    }
    #[inline]
    pub unsafe fn createView(&mut self) -> *mut filament_View {
        filament_Engine_createView(self)
    }
    #[inline]
    pub unsafe fn createScene(&mut self) -> *mut filament_Scene {
        filament_Engine_createScene(self)
    }
    #[inline]
    pub unsafe fn createCamera(&mut self, entity: utils_Entity) -> *mut filament_Camera {
        filament_Engine_createCamera(self, entity)
    }
    #[inline]
    pub unsafe fn getCameraComponent(&mut self, entity: utils_Entity) -> *mut filament_Camera {
        filament_Engine_getCameraComponent(self, entity)
    }
    #[inline]
    pub unsafe fn destroyCameraComponent(&mut self, entity: utils_Entity) {
        filament_Engine_destroyCameraComponent(self, entity)
    }
    #[inline]
    pub unsafe fn createFence(&mut self) -> *mut filament_Fence {
        filament_Engine_createFence(self)
    }
    #[inline]
    pub unsafe fn destroy2(&mut self, p: *const filament_VertexBuffer) {
        filament_Engine_destroy2(self, p)
    }
    #[inline]
    pub unsafe fn destroy3(&mut self, p: *const filament_Fence) {
        filament_Engine_destroy3(self, p)
    }
    #[inline]
    pub unsafe fn destroy4(&mut self, p: *const filament_IndexBuffer) {
        filament_Engine_destroy4(self, p)
    }
    #[inline]
    pub unsafe fn destroy5(&mut self, p: *const filament_IndirectLight) {
        filament_Engine_destroy5(self, p)
    }
    #[inline]
    pub unsafe fn destroy6(&mut self, p: *const filament_Material) {
        filament_Engine_destroy6(self, p)
    }
    #[inline]
    pub unsafe fn destroy7(&mut self, p: *const filament_MaterialInstance) {
        filament_Engine_destroy7(self, p)
    }
    #[inline]
    pub unsafe fn destroy8(&mut self, p: *const filament_Renderer) {
        filament_Engine_destroy8(self, p)
    }
    #[inline]
    pub unsafe fn destroy9(&mut self, p: *const filament_Scene) {
        filament_Engine_destroy9(self, p)
    }
    #[inline]
    pub unsafe fn destroy10(&mut self, p: *const filament_Skybox) {
        filament_Engine_destroy10(self, p)
    }
    #[inline]
    pub unsafe fn destroy11(&mut self, p: *const filament_SwapChain) {
        filament_Engine_destroy11(self, p)
    }
    #[inline]
    pub unsafe fn destroy12(&mut self, p: *const filament_Stream) {
        filament_Engine_destroy12(self, p)
    }
    #[inline]
    pub unsafe fn destroy13(&mut self, p: *const filament_Texture) {
        filament_Engine_destroy13(self, p)
    }
    #[inline]
    pub unsafe fn destroy14(&mut self, p: *const filament_RenderTarget) {
        filament_Engine_destroy14(self, p)
    }
    #[inline]
    pub unsafe fn destroy15(&mut self, p: *const filament_View) {
        filament_Engine_destroy15(self, p)
    }
    #[inline]
    pub unsafe fn destroy16(&mut self, e: utils_Entity) {
        filament_Engine_destroy16(self, e)
    }
    #[inline]
    pub unsafe fn flushAndWait(&mut self) {
        filament_Engine_flushAndWait(self)
    }
    #[inline]
    pub unsafe fn getDefaultMaterial(&self) -> *const filament_Material {
        filament_Engine_getDefaultMaterial(self)
    }
    #[inline]
    pub unsafe fn getBackend(&self) -> filament_Engine_Backend {
        filament_Engine_getBackend(self)
    }
    #[inline]
    pub unsafe fn streamAlloc(
        &mut self,
        size: size_t,
        alignment: size_t,
    ) -> *mut ::std::os::raw::c_void {
        filament_Engine_streamAlloc(self, size, alignment)
    }
    #[inline]
    pub unsafe fn createCamera1(&mut self) -> *mut filament_Camera {
        filament_Engine_createCamera1(self)
    }
    #[inline]
    pub unsafe fn destroy17(&mut self, camera: *const filament_Camera) {
        filament_Engine_destroy17(self, camera)
    }
    #[inline]
    pub unsafe fn execute(&mut self) {
        filament_Engine_execute(self)
    }
    #[inline]
    pub unsafe fn getJobSystem(&mut self) -> *mut utils_JobSystem {
        filament_Engine_getJobSystem(self)
    }
    #[inline]
    pub unsafe fn getDebugRegistry(&mut self) -> *mut filament_DebugRegistry {
        filament_Engine_getDebugRegistry(self)
    }
}
#[doc = " \\privatesection"]
#[doc = " FilamentAPI is used to define an API in filament."]
#[doc = " It ensures the class defining the API can't be created, destroyed"]
#[doc = " or copied by the caller."]
#[repr(C)]
#[derive(Debug)]
pub struct filament_FilamentAPI {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_filament_FilamentAPI() {
    assert_eq!(
        ::std::mem::size_of::<filament_FilamentAPI>(),
        1usize,
        concat!("Size of: ", stringify!(filament_FilamentAPI))
    );
    assert_eq!(
        ::std::mem::align_of::<filament_FilamentAPI>(),
        1usize,
        concat!("Alignment of ", stringify!(filament_FilamentAPI))
    );
}
#[doc = " \\privatesection"]
#[doc = " BuilderBase is used to hide the implementation details of builders and ensure a higher"]
#[doc = " level of backward binary compatibility."]
#[doc = " The actual implementation is in src/FilamentAPI-impl.h\""]
#[repr(C)]
#[derive(Debug)]
pub struct filament_BuilderBase<T> {
    pub mImpl: *mut T,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct filament_Viewport {
    _unused: [u8; 0],
}
#[doc = " A Renderer instance represents an operating system's window."]
#[doc = ""]
#[doc = " Typically, applications create a Renderer per window. The Renderer generates drawing commands"]
#[doc = " for the render thread and manages frame latency."]
#[doc = ""]
#[doc = " A Renderer generates drawing commands from a View, itself containing a Scene description."]
#[doc = ""]
#[doc = " Creation and Destruction"]
#[doc = " ========================"]
#[doc = ""]
#[doc = " A Renderer is created using Engine.createRenderer() and destroyed using"]
#[doc = " Engine.destroy(const Renderer*)."]
#[doc = ""]
#[doc = " ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"]
#[doc = " #include <filament/Renderer.h>"]
#[doc = " #include <filament/Engine.h>"]
#[doc = " using namespace filament;"]
#[doc = ""]
#[doc = " Engine* engine = Engine::create();"]
#[doc = ""]
#[doc = " Renderer* renderer = engine->createRenderer();"]
#[doc = " engine->destroy(&renderer);"]
#[doc = " ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"]
#[doc = ""]
#[doc = " @see Engine, View"]
#[repr(C)]
#[derive(Debug)]
pub struct filament_Renderer {
    pub _address: u8,
}
#[doc = " Use DisplayInfo to set important Display properties. This is used to achieve correct"]
#[doc = " frame pacing and dynamic resolution scaling."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct filament_Renderer_DisplayInfo {
    pub refreshRate: f32,
    pub presentationDeadlineNanos: u64,
    pub vsyncOffsetNanos: u64,
}
#[test]
fn bindgen_test_layout_filament_Renderer_DisplayInfo() {
    assert_eq!(
        ::std::mem::size_of::<filament_Renderer_DisplayInfo>(),
        24usize,
        concat!("Size of: ", stringify!(filament_Renderer_DisplayInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<filament_Renderer_DisplayInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(filament_Renderer_DisplayInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_Renderer_DisplayInfo>())).refreshRate as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_Renderer_DisplayInfo),
            "::",
            stringify!(refreshRate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_Renderer_DisplayInfo>())).presentationDeadlineNanos
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_Renderer_DisplayInfo),
            "::",
            stringify!(presentationDeadlineNanos)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_Renderer_DisplayInfo>())).vsyncOffsetNanos as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_Renderer_DisplayInfo),
            "::",
            stringify!(vsyncOffsetNanos)
        )
    );
}
#[doc = " Use FrameRateOptions to set the desired frame rate and control how quickly the system"]
#[doc = " reacts to GPU load changes."]
#[doc = ""]
#[doc = " interval: desired frame interval in multiple of the refresh period, set in DisplayInfo"]
#[doc = "           (as 1 / DisplayInfo::refreshRate)"]
#[doc = ""]
#[doc = " The parameters below are relevant when some Views are using dynamic resolution scaling:"]
#[doc = ""]
#[doc = " headRoomRatio: additional headroom for the GPU as a ratio of the targetFrameTime."]
#[doc = "                Useful for taking into account constant costs like post-processing or"]
#[doc = "                GPU drivers on different platforms."]
#[doc = " history:   History size. higher values, tend to filter more (clamped to 30)"]
#[doc = " scaleRate: rate at which the gpu load is adjusted to reach the target frame rate"]
#[doc = "            This value can be computed as 1 / N, where N is the number of frames"]
#[doc = "            needed to reach 64% of the target scale factor."]
#[doc = "            Higher values make the dynamic resolution react faster."]
#[doc = ""]
#[doc = " @see View::DynamicResolutionOptions"]
#[doc = " @see Renderer::DisplayInfo"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct filament_Renderer_FrameRateOptions {
    #[doc = "!< additional headroom for the GPU"]
    pub headRoomRatio: f32,
    #[doc = "!< rate at which the system reacts to load changes"]
    pub scaleRate: f32,
    #[doc = "!< history size"]
    pub history: u8,
    #[doc = "!< desired frame interval in unit of 1.0 / DisplayInfo::refreshRate"]
    pub interval: u8,
}
#[test]
fn bindgen_test_layout_filament_Renderer_FrameRateOptions() {
    assert_eq!(
        ::std::mem::size_of::<filament_Renderer_FrameRateOptions>(),
        12usize,
        concat!("Size of: ", stringify!(filament_Renderer_FrameRateOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<filament_Renderer_FrameRateOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(filament_Renderer_FrameRateOptions)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_Renderer_FrameRateOptions>())).headRoomRatio as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_Renderer_FrameRateOptions),
            "::",
            stringify!(headRoomRatio)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_Renderer_FrameRateOptions>())).scaleRate as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_Renderer_FrameRateOptions),
            "::",
            stringify!(scaleRate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_Renderer_FrameRateOptions>())).history as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_Renderer_FrameRateOptions),
            "::",
            stringify!(history)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_Renderer_FrameRateOptions>())).interval as *const _
                as usize
        },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_Renderer_FrameRateOptions),
            "::",
            stringify!(interval)
        )
    );
}
#[doc = " ClearOptions are used at the beginning of a frame to clear or retain the SwapChain content."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct filament_Renderer_ClearOptions {
    #[doc = " Color to use to clear the SwapChain"]
    pub clearColor: filament_math_float4,
    #[doc = " Whether the SwapChain should be cleared using the clearColor. Use this if translucent"]
    #[doc = " View will be drawn, for instance."]
    pub clear: bool,
    #[doc = " Whether the SwapChain content should be discarded. clear implies discard. Set this"]
    #[doc = " to false (along with clear to false as well) if the SwapChain already has content that"]
    #[doc = " needs to be preserved"]
    pub discard: bool,
}
#[test]
fn bindgen_test_layout_filament_Renderer_ClearOptions() {
    assert_eq!(
        ::std::mem::size_of::<filament_Renderer_ClearOptions>(),
        20usize,
        concat!("Size of: ", stringify!(filament_Renderer_ClearOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<filament_Renderer_ClearOptions>(),
        4usize,
        concat!("Alignment of ", stringify!(filament_Renderer_ClearOptions))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_Renderer_ClearOptions>())).clearColor as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_Renderer_ClearOptions),
            "::",
            stringify!(clearColor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_Renderer_ClearOptions>())).clear as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_Renderer_ClearOptions),
            "::",
            stringify!(clear)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_Renderer_ClearOptions>())).discard as *const _ as usize
        },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_Renderer_ClearOptions),
            "::",
            stringify!(discard)
        )
    );
}
#[doc = " Flags used to configure the behavior of copyFrame()."]
#[doc = ""]
#[doc = " @see"]
#[doc = " copyFrame()"]
pub type filament_Renderer_CopyFrameFlag = u32;
pub const filament_Renderer_COMMIT: filament_Renderer_CopyFrameFlag = 1;
pub const filament_Renderer_SET_PRESENTATION_TIME: filament_Renderer_CopyFrameFlag = 2;
pub const filament_Renderer_CLEAR: filament_Renderer_CopyFrameFlag = 4;
#[test]
fn bindgen_test_layout_filament_Renderer() {
    assert_eq!(
        ::std::mem::size_of::<filament_Renderer>(),
        1usize,
        concat!("Size of: ", stringify!(filament_Renderer))
    );
    assert_eq!(
        ::std::mem::align_of::<filament_Renderer>(),
        1usize,
        concat!("Alignment of ", stringify!(filament_Renderer))
    );
}
extern "C" {
    #[doc = " Information about the display this Renderer is associated to. This information is needed"]
    #[doc = " to accurately compute dynamic-resolution scaling and for frame-pacing."]
    #[doc = ""]
    #[doc = " @param info"]
    #[link_name = "\u{1}_ZN8filament8Renderer14setDisplayInfoERKNS0_11DisplayInfoE"]
    pub fn filament_Renderer_setDisplayInfo(
        this: *mut filament_Renderer,
        info: *const filament_Renderer_DisplayInfo,
    );
}
extern "C" {
    #[doc = " Set options controlling the desired frame-rate."]
    #[doc = ""]
    #[doc = " @param options"]
    #[link_name = "\u{1}_ZN8filament8Renderer19setFrameRateOptionsERKNS0_16FrameRateOptionsE"]
    pub fn filament_Renderer_setFrameRateOptions(
        this: *mut filament_Renderer,
        options: *const filament_Renderer_FrameRateOptions,
    );
}
extern "C" {
    #[doc = " Set ClearOptions which are used at the beginning of a frame to clear or retain the"]
    #[doc = " SwapChain content."]
    #[doc = ""]
    #[doc = " @param options"]
    #[link_name = "\u{1}_ZN8filament8Renderer15setClearOptionsERKNS0_12ClearOptionsE"]
    pub fn filament_Renderer_setClearOptions(
        this: *mut filament_Renderer,
        options: *const filament_Renderer_ClearOptions,
    );
}
extern "C" {
    #[doc = " Get the Engine that created this Renderer."]
    #[doc = ""]
    #[doc = " @return A pointer to the Engine instance this Renderer is associated to."]
    #[link_name = "\u{1}_ZN8filament8Renderer9getEngineEv"]
    pub fn filament_Renderer_getEngine(this: *mut filament_Renderer) -> *mut filament_Engine;
}
extern "C" {
    #[doc = " Render a View into this renderer's window."]
    #[doc = ""]
    #[doc = " This is filament main rendering method, most of the CPU-side heavy lifting is performed"]
    #[doc = " here. render() main function is to generate render commands which are asynchronously"]
    #[doc = " executed by the Engine's render thread."]
    #[doc = ""]
    #[doc = " render() generates commands for each of the following stages:"]
    #[doc = ""]
    #[doc = " 1. Shadow map pass, if needed (currently only a single shadow map is supported)."]
    #[doc = " 2. Depth pre-pass."]
    #[doc = " 3. Color pass."]
    #[doc = " 4. Post-processing pass."]
    #[doc = ""]
    #[doc = " A typical render loop looks like this:"]
    #[doc = " ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"]
    #[doc = " #include <filament/Renderer.h>"]
    #[doc = " #include <filament/View.h>"]
    #[doc = " using namespace filament;"]
    #[doc = ""]
    #[doc = " void renderLoop(Renderer* renderer, SwapChain* swapChain) {"]
    #[doc = "     do {"]
    #[doc = "         // typically we wait for VSYNC and user input events"]
    #[doc = "         if (renderer->beginFrame(swapChain)) {"]
    #[doc = "             renderer->render(mView);"]
    #[doc = "             renderer->endFrame();"]
    #[doc = "         }"]
    #[doc = "     } while (!quit());"]
    #[doc = " }"]
    #[doc = " ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @param view A pointer to the view to render."]
    #[doc = ""]
    #[doc = " @attention"]
    #[doc = " render() must be called *after* beginFrame() and *before* endFrame()."]
    #[doc = ""]
    #[doc = " @note"]
    #[doc = " render() must be called from the Engine's main thread (or external synchronization"]
    #[doc = " must be provided). In particular, calls to render() on different Renderer instances"]
    #[doc = " **must** be synchronized."]
    #[doc = ""]
    #[doc = " @remark"]
    #[doc = " render() perform potentially heavy computations and cannot be multi-threaded. However,"]
    #[doc = " internally, render() is highly multi-threaded to both improve performance in mitigate"]
    #[doc = " the call's latency."]
    #[doc = ""]
    #[doc = " @remark"]
    #[doc = " render() is typically called once per frame (but not necessarily)."]
    #[doc = ""]
    #[doc = " @see"]
    #[doc = " beginFrame(), endFrame(), View"]
    #[doc = ""]
    #[link_name = "\u{1}_ZN8filament8Renderer6renderEPKNS_4ViewE"]
    pub fn filament_Renderer_render(this: *mut filament_Renderer, view: *const filament_View);
}
extern "C" {
    #[doc = " Copy the currently rendered view to the indicated swap chain, using the"]
    #[doc = " indicated source and destination rectangle."]
    #[doc = ""]
    #[doc = " @param dstSwapChain The swap chain into which the frame should be copied."]
    #[doc = " @param dstViewport The destination rectangle in which to draw the view."]
    #[doc = " @param srcViewport The source rectangle to be copied."]
    #[doc = " @param flags One or more CopyFrameFlag behavior configuration flags."]
    #[doc = ""]
    #[doc = " @remark"]
    #[doc = " copyFrame() should be called after a frame is rendered using render()"]
    #[doc = " but before endFrame() is called."]
    #[link_name = "\u{1}_ZN8filament8Renderer9copyFrameEPNS_9SwapChainERKNS_8ViewportES5_j"]
    pub fn filament_Renderer_copyFrame(
        this: *mut filament_Renderer,
        dstSwapChain: *mut filament_SwapChain,
        dstViewport: *const filament_Viewport,
        srcViewport: *const filament_Viewport,
        flags: u32,
    );
}
extern "C" {
    #[doc = " Reads back the content of the SwapChain associated with this Renderer."]
    #[doc = ""]
    #[doc = " @param xoffset   Left offset of the sub-region to read back."]
    #[doc = " @param yoffset   Bottom offset of the sub-region to read back."]
    #[doc = " @param width     Width of the sub-region to read back."]
    #[doc = " @param height    Height of the sub-region to read back."]
    #[doc = " @param buffer    Client-side buffer where the read-back will be written."]
    #[doc = ""]
    #[doc = "                  The following format are always supported:"]
    #[doc = "                      - PixelBufferDescriptor::PixelDataFormat::RGBA"]
    #[doc = "                      - PixelBufferDescriptor::PixelDataFormat::RGBA_INTEGER"]
    #[doc = ""]
    #[doc = "                  The following types are always supported:"]
    #[doc = "                      - PixelBufferDescriptor::PixelDataType::UBYTE"]
    #[doc = "                      - PixelBufferDescriptor::PixelDataType::UINT"]
    #[doc = "                      - PixelBufferDescriptor::PixelDataType::INT"]
    #[doc = "                      - PixelBufferDescriptor::PixelDataType::FLOAT"]
    #[doc = ""]
    #[doc = "                  Other combination of format/type may be supported. If a combination is"]
    #[doc = "                  not supported, this operation may fail silently. Use a DEBUG build"]
    #[doc = "                  to get some logs about the failure."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  Framebuffer as seen on         User buffer (PixelBufferDescriptor&)"]
    #[doc = "  screen"]
    #[doc = "  +--------------------+"]
    #[doc = "  |                    |                .stride         .alignment"]
    #[doc = "  |                    |         ----------------------->-->"]
    #[doc = "  |                    |         O----------------------+--+   low addresses"]
    #[doc = "  |                    |         |          |           |  |"]
    #[doc = "  |             w      |         |          | .top      |  |"]
    #[doc = "  |       <--------->  |         |          V           |  |"]
    #[doc = "  |       +---------+  |         |     +---------+      |  |"]
    #[doc = "  |       |     ^   |  | ======> |     |         |      |  |"]
    #[doc = "  |   x   |    h|   |  |         |.left|         |      |  |"]
    #[doc = "  +------>|     v   |  |         +---->|         |      |  |"]
    #[doc = "  |       +.........+  |         |     +.........+      |  |"]
    #[doc = "  |            ^       |         |                      |  |"]
    #[doc = "  |          y |       |         +----------------------+--+  high addresses"]
    #[doc = "  O------------+-------+"]
    #[doc = ""]
    #[doc = ""]
    #[doc = " Typically readPixels() will be called after render() and before endFrame()."]
    #[doc = ""]
    #[doc = " After issuing this method, the callback associated with `buffer` will be invoked on the"]
    #[doc = " main thread, indicating that the read-back has completed. Typically, this will happen"]
    #[doc = " after multiple calls to beginFrame(), render(), endFrame()."]
    #[doc = ""]
    #[doc = " It is also possible to use a Fence to wait for the read-back."]
    #[doc = ""]
    #[doc = " @remark"]
    #[doc = " readPixels() is intended for debugging and testing. It will impact performance significantly."]
    #[doc = ""]
    #[link_name = "\u{1}_ZN8filament8Renderer10readPixelsEjjjjONS_7backend21PixelBufferDescriptorE"]
    pub fn filament_Renderer_readPixels(
        this: *mut filament_Renderer,
        xoffset: u32,
        yoffset: u32,
        width: u32,
        height: u32,
        buffer: *mut filament_backend_PixelBufferDescriptor,
    );
}
extern "C" {
    #[doc = " Reads back the content of the provided RenderTarget."]
    #[doc = ""]
    #[doc = " @param renderTarget  RenderTarget to read back from."]
    #[doc = " @param xoffset       Left offset of the sub-region to read back."]
    #[doc = " @param yoffset       Bottom offset of the sub-region to read back."]
    #[doc = " @param width         Width of the sub-region to read back."]
    #[doc = " @param height        Height of the sub-region to read back."]
    #[doc = " @param buffer        Client-side buffer where the read-back will be written."]
    #[doc = ""]
    #[doc = "                  The following format are always supported:"]
    #[doc = "                      - PixelBufferDescriptor::PixelDataFormat::RGBA"]
    #[doc = "                      - PixelBufferDescriptor::PixelDataFormat::RGBA_INTEGER"]
    #[doc = ""]
    #[doc = "                  The following types are always supported:"]
    #[doc = "                      - PixelBufferDescriptor::PixelDataType::UBYTE"]
    #[doc = "                      - PixelBufferDescriptor::PixelDataType::UINT"]
    #[doc = "                      - PixelBufferDescriptor::PixelDataType::INT"]
    #[doc = "                      - PixelBufferDescriptor::PixelDataType::FLOAT"]
    #[doc = ""]
    #[doc = "                  Other combination of format/type may be supported. If a combination is"]
    #[doc = "                  not supported, this operation may fail silently. Use a DEBUG build"]
    #[doc = "                  to get some logs about the failure."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  Framebuffer as seen on         User buffer (PixelBufferDescriptor&)"]
    #[doc = "  screen"]
    #[doc = "  +--------------------+"]
    #[doc = "  |                    |                .stride         .alignment"]
    #[doc = "  |                    |         ----------------------->-->"]
    #[doc = "  |                    |         O----------------------+--+   low addresses"]
    #[doc = "  |                    |         |          |           |  |"]
    #[doc = "  |             w      |         |          | .top      |  |"]
    #[doc = "  |       <--------->  |         |          V           |  |"]
    #[doc = "  |       +---------+  |         |     +---------+      |  |"]
    #[doc = "  |       |     ^   |  | ======> |     |         |      |  |"]
    #[doc = "  |   x   |    h|   |  |         |.left|         |      |  |"]
    #[doc = "  +------>|     v   |  |         +---->|         |      |  |"]
    #[doc = "  |       +.........+  |         |     +.........+      |  |"]
    #[doc = "  |            ^       |         |                      |  |"]
    #[doc = "  |          y |       |         +----------------------+--+  high addresses"]
    #[doc = "  O------------+-------+"]
    #[doc = ""]
    #[doc = ""]
    #[doc = " Typically readPixels() will be called after render() and before endFrame()."]
    #[doc = ""]
    #[doc = " After issuing this method, the callback associated with `buffer` will be invoked on the"]
    #[doc = " main thread, indicating that the read-back has completed. Typically, this will happen"]
    #[doc = " after multiple calls to beginFrame(), render(), endFrame()."]
    #[doc = ""]
    #[doc = " It is also possible to use a Fence to wait for the read-back."]
    #[doc = ""]
    #[doc = " @remark"]
    #[doc = " readPixels() is intended for debugging and testing. It will impact performance significantly."]
    #[doc = ""]
    #[link_name = "\u{1}_ZN8filament8Renderer10readPixelsEPNS_12RenderTargetEjjjjONS_7backend21PixelBufferDescriptorE"]
    pub fn filament_Renderer_readPixels1(
        this: *mut filament_Renderer,
        renderTarget: *mut filament_RenderTarget,
        xoffset: u32,
        yoffset: u32,
        width: u32,
        height: u32,
        buffer: *mut filament_backend_PixelBufferDescriptor,
    );
}
extern "C" {
    #[doc = " Set-up a frame for this Renderer."]
    #[doc = ""]
    #[doc = " beginFrame() manages frame pacing, and returns whether or not a frame should be drawn. The"]
    #[doc = " goal of this is to skip frames when the GPU falls behind in order to keep the frame"]
    #[doc = " latency low."]
    #[doc = ""]
    #[doc = " If a given frame takes too much time in the GPU, the CPU will get ahead of the GPU. The"]
    #[doc = " display will draw the same frame twice producing a stutter. At this point, the CPU is"]
    #[doc = " ahead of the GPU and depending on how many frames are buffered, latency increases."]
    #[doc = ""]
    #[doc = " beginFrame() attempts to detect this situation and returns false in that case, indicating"]
    #[doc = " to the caller to skip the current frame."]
    #[doc = ""]
    #[doc = " When beginFrame() returns true, it is mandatory to render the frame and call endFrame()."]
    #[doc = " However, when beginFrame() returns false, the caller has the choice to either skip the"]
    #[doc = " frame and not call endFrame(), or proceed as though true was returned."]
    #[doc = ""]
    #[doc = " Typically, Filament is responsible for scheduling the frame's presentation to the SwapChain."]
    #[doc = " If a backend::FrameFinishedCallback is provided, however, the application bares the"]
    #[doc = " responsibility of scheduling a frame for presentation by calling the backend::PresentCallable"]
    #[doc = " passed to the callback function. Currently this functionality is only supported by the Metal"]
    #[doc = " backend."]
    #[doc = ""]
    #[doc = " @param vsyncSteadyClockTimeNano The time in nanosecond of when the current frame started,"]
    #[doc = "                                 or 0 if unknown. This value should be the timestamp of"]
    #[doc = "                                 the last h/w vsync. It is expressed in the"]
    #[doc = "                                 std::chrono::steady_clock time base."]
    #[doc = " @param swapChain A pointer to the SwapChain instance to use."]
    #[doc = " @param callback  A callback function that will be called when the backend has finished"]
    #[doc = "                  processing the frame."]
    #[doc = " @param user      User data to be passed to the callback function."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      *false* the current frame should be skipped,"]
    #[doc = "      *true* the current frame must be drawn and endFrame() must be called."]
    #[doc = ""]
    #[doc = " @remark"]
    #[doc = " When skipping a frame, the whole frame is canceled, and endFrame() must not be called."]
    #[doc = ""]
    #[doc = " @note"]
    #[doc = " All calls to render() must happen *after* beginFrame()."]
    #[doc = ""]
    #[doc = " @see"]
    #[doc = " endFrame(), backend::PresentCallable, backend::FrameFinishedCallback"]
    #[link_name = "\u{1}_ZN8filament8Renderer10beginFrameEPNS_9SwapChainEmPFvNS_7backend15PresentCallableEPvES5_"]
    pub fn filament_Renderer_beginFrame(
        this: *mut filament_Renderer,
        swapChain: *mut filament_SwapChain,
        vsyncSteadyClockTimeNano: u64,
        callback: filament_backend_FrameFinishedCallback,
        user: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = " Finishes the current frame and schedules it for display."]
    #[doc = ""]
    #[doc = " endFrame() schedules the current frame to be displayed on the Renderer's window."]
    #[doc = ""]
    #[doc = " @note"]
    #[doc = " All calls to render() must happen *before* endFrame(). endFrame() must be called if"]
    #[doc = " beginFrame() returned true, otherwise, endFrame() must not be called unless the caller"]
    #[doc = " ignored beginFrame()'s return value."]
    #[doc = ""]
    #[doc = " @see"]
    #[doc = " beginFrame()"]
    #[link_name = "\u{1}_ZN8filament8Renderer8endFrameEv"]
    pub fn filament_Renderer_endFrame(this: *mut filament_Renderer);
}
extern "C" {
    #[doc = " Returns the time in second of the last call to beginFrame(). This value is constant for all"]
    #[doc = " views rendered during a frame. The epoch is set with resetUserTime()."]
    #[doc = ""]
    #[doc = " In materials, this value can be queried using `vec4 getUserTime()`. The value returned"]
    #[doc = " is a highp vec4 encoded as follows:"]
    #[doc = ""]
    #[doc = "      time.x = (float)Renderer.getUserTime();"]
    #[doc = "      time.y = Renderer.getUserTime() - time.x;"]
    #[doc = ""]
    #[doc = " It follows that the following invariants are true:"]
    #[doc = ""]
    #[doc = "      (double)time.x + (double)time.y == Renderer.getUserTime()"]
    #[doc = "      time.x == (float)Renderer.getUserTime()"]
    #[doc = ""]
    #[doc = " This encoding allows the shader code to perform high precision (i.e. double) time"]
    #[doc = " calculations when needed despite the lack of double precision in the shader, for e.g.:"]
    #[doc = ""]
    #[doc = "      To compute (double)time * vertex in the material, use the following construct:"]
    #[doc = ""]
    #[doc = "              vec3 result = time.x * vertex + time.y * vertex;"]
    #[doc = ""]
    #[doc = ""]
    #[doc = " Most of the time, high precision computations are not required, but be aware that the"]
    #[doc = " precision of time.x rapidly diminishes as time passes:"]
    #[doc = ""]
    #[doc = "          time    | precision"]
    #[doc = "          --------+----------"]
    #[doc = "          16.7s   |    us"]
    #[doc = "          4h39    |    ms"]
    #[doc = "         77h      |   1/60s"]
    #[doc = ""]
    #[doc = ""]
    #[doc = " In other words, it only possible to get microsecond accuracy for about 16s or millisecond"]
    #[doc = " accuracy for just under 5h."]
    #[doc = ""]
    #[doc = " This problem can be mitigated by calling resetUserTime(), or using high precision time as"]
    #[doc = " described above."]
    #[doc = ""]
    #[doc = " @return The time is seconds since resetUserTime() was last called."]
    #[doc = ""]
    #[doc = " @see"]
    #[doc = " resetUserTime()"]
    #[link_name = "\u{1}_ZNK8filament8Renderer11getUserTimeEv"]
    pub fn filament_Renderer_getUserTime(this: *const filament_Renderer) -> f64;
}
extern "C" {
    #[doc = " Sets the user time epoch to now, i.e. resets the user time to zero."]
    #[doc = ""]
    #[doc = " Use this method used to keep the precision of time high in materials, in practice it should"]
    #[doc = " be called at least when the application is paused, e.g. Activity.onPause() in Android."]
    #[doc = ""]
    #[doc = " @see"]
    #[doc = " getUserTime()"]
    #[link_name = "\u{1}_ZN8filament8Renderer13resetUserTimeEv"]
    pub fn filament_Renderer_resetUserTime(this: *mut filament_Renderer);
}
impl filament_Renderer {
    #[inline]
    pub unsafe fn setDisplayInfo(&mut self, info: *const filament_Renderer_DisplayInfo) {
        filament_Renderer_setDisplayInfo(self, info)
    }
    #[inline]
    pub unsafe fn setFrameRateOptions(
        &mut self,
        options: *const filament_Renderer_FrameRateOptions,
    ) {
        filament_Renderer_setFrameRateOptions(self, options)
    }
    #[inline]
    pub unsafe fn setClearOptions(&mut self, options: *const filament_Renderer_ClearOptions) {
        filament_Renderer_setClearOptions(self, options)
    }
    #[inline]
    pub unsafe fn getEngine(&mut self) -> *mut filament_Engine {
        filament_Renderer_getEngine(self)
    }
    #[inline]
    pub unsafe fn render(&mut self, view: *const filament_View) {
        filament_Renderer_render(self, view)
    }
    #[inline]
    pub unsafe fn copyFrame(
        &mut self,
        dstSwapChain: *mut filament_SwapChain,
        dstViewport: *const filament_Viewport,
        srcViewport: *const filament_Viewport,
        flags: u32,
    ) {
        filament_Renderer_copyFrame(self, dstSwapChain, dstViewport, srcViewport, flags)
    }
    #[inline]
    pub unsafe fn readPixels(
        &mut self,
        xoffset: u32,
        yoffset: u32,
        width: u32,
        height: u32,
        buffer: *mut filament_backend_PixelBufferDescriptor,
    ) {
        filament_Renderer_readPixels(self, xoffset, yoffset, width, height, buffer)
    }
    #[inline]
    pub unsafe fn readPixels1(
        &mut self,
        renderTarget: *mut filament_RenderTarget,
        xoffset: u32,
        yoffset: u32,
        width: u32,
        height: u32,
        buffer: *mut filament_backend_PixelBufferDescriptor,
    ) {
        filament_Renderer_readPixels1(self, renderTarget, xoffset, yoffset, width, height, buffer)
    }
    #[inline]
    pub unsafe fn beginFrame(
        &mut self,
        swapChain: *mut filament_SwapChain,
        vsyncSteadyClockTimeNano: u64,
        callback: filament_backend_FrameFinishedCallback,
        user: *mut ::std::os::raw::c_void,
    ) -> bool {
        filament_Renderer_beginFrame(self, swapChain, vsyncSteadyClockTimeNano, callback, user)
    }
    #[inline]
    pub unsafe fn endFrame(&mut self) {
        filament_Renderer_endFrame(self)
    }
    #[inline]
    pub unsafe fn getUserTime(&self) -> f64 {
        filament_Renderer_getUserTime(self)
    }
    #[inline]
    pub unsafe fn resetUserTime(&mut self) {
        filament_Renderer_resetUserTime(self)
    }
}
#[doc = " A swap chain represents an Operating System's *native* renderable surface."]
#[doc = ""]
#[doc = " Typically it's a native window or a view. Because a SwapChain is initialized from a"]
#[doc = " native object, it is given to filament as a `void *`, which must be of the proper type"]
#[doc = " for each platform filament is running on."]
#[doc = ""]
#[doc = " \\code"]
#[doc = " SwapChain* swapChain = engine->createSwapChain(nativeWindow);"]
#[doc = " \\endcode"]
#[doc = ""]
#[doc = " When Engine::create() is used without specifying a Platform, the `nativeWindow`"]
#[doc = " parameter above must be of type:"]
#[doc = ""]
#[doc = " Platform | nativeWindow type"]
#[doc = " :--------|:----------------------------:"]
#[doc = " Android  | ANativeWindow*"]
#[doc = " OSX      | NSView*"]
#[doc = " IOS      | CAEAGLLayer*"]
#[doc = " X11      | Window"]
#[doc = " Windows  | HWND"]
#[doc = ""]
#[doc = " Otherwise, the `nativeWindow` is defined by the concrete implementation of Platform."]
#[doc = ""]
#[doc = ""]
#[doc = " Examples:"]
#[doc = ""]
#[doc = " Android"]
#[doc = " -------"]
#[doc = ""]
#[doc = " On Android, an `ANativeWindow*` can be obtained from a Java `Surface` object using:"]
#[doc = ""]
#[doc = " ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"]
#[doc = "  #include <android/native_window_jni.h>"]
#[doc = "  // parameters"]
#[doc = "  // env:         JNIEnv*"]
#[doc = "  // surface:     jobject"]
#[doc = "  ANativeWindow* win = ANativeWindow_fromSurface(env, surface);"]
#[doc = " ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"]
#[doc = ""]
#[doc = " \\warning"]
#[doc = " Don't use reflection to access the `mNativeObject` field, it won't work."]
#[doc = ""]
#[doc = " A `Surface` can be retrieved from a `SurfaceView` or `SurfaceHolder` easily using"]
#[doc = " `SurfaceHolder.getSurface()` and/or `SurfaceView.getHolder()`."]
#[doc = ""]
#[doc = " \\note"]
#[doc = " To use a `TextureView` as a SwapChain, it is necessary to first get its `SurfaceTexture`,"]
#[doc = " for instance using `TextureView.SurfaceTextureListener` and then create a `Surface`:"]
#[doc = ""]
#[doc = " ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.java}"]
#[doc = "  // using a TextureView.SurfaceTextureListener:"]
#[doc = "  public void onSurfaceTextureAvailable(SurfaceTexture surfaceTexture, int width, int height) {"]
#[doc = "      mSurface = new Surface(surfaceTexture);"]
#[doc = "      // mSurface can now be used in JNI to create an ANativeWindow."]
#[doc = "  }"]
#[doc = " ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"]
#[doc = ""]
#[doc = " Linux"]
#[doc = " -----"]
#[doc = ""]
#[doc = " Example using SDL:"]
#[doc = ""]
#[doc = " ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"]
#[doc = " SDL_SysWMinfo wmi;"]
#[doc = " SDL_VERSION(&wmi.version);"]
#[doc = " SDL_GetWindowWMInfo(sdlWindow, &wmi);"]
#[doc = " Window nativeWindow = (Window) wmi.info.x11.window;"]
#[doc = ""]
#[doc = " using namespace filament;"]
#[doc = " Engine* engine       = Engine::create();"]
#[doc = " SwapChain* swapChain = engine->createSwapChain((void*) nativeWindow);"]
#[doc = " ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"]
#[doc = ""]
#[doc = " Windows"]
#[doc = " -------"]
#[doc = ""]
#[doc = " Example using SDL:"]
#[doc = ""]
#[doc = " ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"]
#[doc = " SDL_SysWMinfo wmi;"]
#[doc = " SDL_VERSION(&wmi.version);"]
#[doc = " ASSERT_POSTCONDITION(SDL_GetWindowWMInfo(sdlWindow, &wmi), \"SDL version unsupported!\");"]
#[doc = " HDC nativeWindow = (HDC) wmi.info.win.hdc;"]
#[doc = ""]
#[doc = " using namespace filament;"]
#[doc = " Engine* engine       = Engine::create();"]
#[doc = " SwapChain* swapChain = engine->createSwapChain((void*) nativeWindow);"]
#[doc = " ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"]
#[doc = ""]
#[doc = " OSX"]
#[doc = " ---"]
#[doc = ""]
#[doc = " On OSX, any `NSView` can be used *directly* as a `nativeWindow` with createSwapChain()."]
#[doc = ""]
#[doc = " Example using SDL/Objective-C:"]
#[doc = ""]
#[doc = " ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.mm}"]
#[doc = "  #include <filament/Engine.h>"]
#[doc = ""]
#[doc = "  #include <Cocoa/Cocoa.h>"]
#[doc = "  #include <SDL_syswm.h>"]
#[doc = ""]
#[doc = "  SDL_SysWMinfo wmi;"]
#[doc = "  SDL_VERSION(&wmi.version);"]
#[doc = "  NSWindow* win = (NSWindow*) wmi.info.cocoa.window;"]
#[doc = "  NSView* view = [win contentView];"]
#[doc = "  void* nativeWindow = view;"]
#[doc = ""]
#[doc = "  using namespace filament;"]
#[doc = "  Engine* engine       = Engine::create();"]
#[doc = "  SwapChain* swapChain = engine->createSwapChain(nativeWindow);"]
#[doc = " ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"]
#[doc = ""]
#[doc = " @see Engine"]
#[repr(C)]
#[derive(Debug)]
pub struct filament_SwapChain {
    pub _address: u8,
}
pub const filament_SwapChain_CONFIG_TRANSPARENT: u64 = 1;
pub const filament_SwapChain_CONFIG_READABLE: u64 = 2;
#[test]
fn bindgen_test_layout_filament_SwapChain() {
    assert_eq!(
        ::std::mem::size_of::<filament_SwapChain>(),
        1usize,
        concat!("Size of: ", stringify!(filament_SwapChain))
    );
    assert_eq!(
        ::std::mem::align_of::<filament_SwapChain>(),
        1usize,
        concat!("Alignment of ", stringify!(filament_SwapChain))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK8filament9SwapChain15getNativeWindowEv"]
    pub fn filament_SwapChain_getNativeWindow(
        this: *const filament_SwapChain,
    ) -> *mut ::std::os::raw::c_void;
}
impl filament_SwapChain {
    #[inline]
    pub unsafe fn getNativeWindow(&self) -> *mut ::std::os::raw::c_void {
        filament_SwapChain_getNativeWindow(self)
    }
}
#[doc = " A Scene is a flat container of Renderable and Light instances."]
#[doc = ""]
#[doc = " A Scene doesn't provide a hierarchy of Renderable objects, i.e.: it's not a scene-graph."]
#[doc = " However, it manages the list of objects to render and the list of lights. Renderable"]
#[doc = " and Light objects can be added or removed from a Scene at any time."]
#[doc = ""]
#[doc = " A Renderable *must* be added to a Scene in order to be rendered, and the Scene must be"]
#[doc = " provided to a View."]
#[doc = ""]
#[doc = ""]
#[doc = " Creation and Destruction"]
#[doc = " ========================"]
#[doc = ""]
#[doc = " A Scene is created using Engine.createScene() and destroyed using"]
#[doc = " Engine.destroy(const Scene*)."]
#[doc = ""]
#[doc = " ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"]
#[doc = " #include <filament/Scene.h>"]
#[doc = " #include <filament/Engine.h>"]
#[doc = " using namespace filament;"]
#[doc = ""]
#[doc = " Engine* engine = Engine::create();"]
#[doc = ""]
#[doc = " Scene* scene = engine->createScene();"]
#[doc = " engine->destroy(&scene);"]
#[doc = " ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"]
#[doc = ""]
#[doc = " @see View, Renderable, Light"]
#[repr(C)]
#[derive(Debug)]
pub struct filament_Scene {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_filament_Scene() {
    assert_eq!(
        ::std::mem::size_of::<filament_Scene>(),
        1usize,
        concat!("Size of: ", stringify!(filament_Scene))
    );
    assert_eq!(
        ::std::mem::align_of::<filament_Scene>(),
        1usize,
        concat!("Alignment of ", stringify!(filament_Scene))
    );
}
extern "C" {
    #[doc = " Sets the SkyBox."]
    #[doc = ""]
    #[doc = " The Skybox is drawn last and covers all pixels not touched by geometry."]
    #[doc = ""]
    #[doc = " @param skybox The Skybox to use to fill untouched pixels, or nullptr to unset the Skybox."]
    #[link_name = "\u{1}_ZN8filament5Scene9setSkyboxEPNS_6SkyboxE"]
    pub fn filament_Scene_setSkybox(this: *mut filament_Scene, skybox: *mut filament_Skybox);
}
extern "C" {
    #[doc = " Set the IndirectLight to use when rendering the Scene."]
    #[doc = ""]
    #[doc = " Currently, a Scene may only have a single IndirectLight. This call replaces the current"]
    #[doc = " IndirectLight."]
    #[doc = ""]
    #[doc = " @param ibl The IndirectLight to use when rendering the Scene or nullptr to unset."]
    #[link_name = "\u{1}_ZN8filament5Scene16setIndirectLightEPKNS_13IndirectLightE"]
    pub fn filament_Scene_setIndirectLight(
        this: *mut filament_Scene,
        ibl: *const filament_IndirectLight,
    );
}
extern "C" {
    #[doc = " Adds an Entity to the Scene."]
    #[doc = ""]
    #[doc = " @param entity The entity is ignored if it doesn't have a Renderable or Light component."]
    #[doc = ""]
    #[doc = " \\attention"]
    #[doc = "  A given Entity object can only be added once to a Scene."]
    #[doc = ""]
    #[link_name = "\u{1}_ZN8filament5Scene9addEntityEN5utils6EntityE"]
    pub fn filament_Scene_addEntity(this: *mut filament_Scene, entity: utils_Entity);
}
extern "C" {
    #[doc = " Adds a contiguous list of entities to the Scene."]
    #[doc = ""]
    #[doc = " @param entities Array containing entities to add to the scene."]
    #[doc = " @param count Size of the entity array."]
    #[link_name = "\u{1}_ZN8filament5Scene11addEntitiesEPKN5utils6EntityEm"]
    pub fn filament_Scene_addEntities(
        this: *mut filament_Scene,
        entities: *const utils_Entity,
        count: size_t,
    );
}
extern "C" {
    #[doc = " Removes the Renderable from the Scene."]
    #[doc = ""]
    #[doc = " @param entity The Entity to remove from the Scene. If the specified"]
    #[doc = "                   \\p entity doesn't exist, this call is ignored."]
    #[link_name = "\u{1}_ZN8filament5Scene6removeEN5utils6EntityE"]
    pub fn filament_Scene_remove(this: *mut filament_Scene, entity: utils_Entity);
}
extern "C" {
    #[doc = " Returns the number of Renderable objects in the Scene."]
    #[doc = ""]
    #[doc = " @return number of Renderable objects in the Scene."]
    #[link_name = "\u{1}_ZNK8filament5Scene18getRenderableCountEv"]
    pub fn filament_Scene_getRenderableCount(this: *const filament_Scene) -> size_t;
}
extern "C" {
    #[doc = " Returns the total number of Light objects in the Scene."]
    #[doc = ""]
    #[doc = " @return The total number of Light objects in the Scene."]
    #[link_name = "\u{1}_ZNK8filament5Scene13getLightCountEv"]
    pub fn filament_Scene_getLightCount(this: *const filament_Scene) -> size_t;
}
extern "C" {
    #[doc = " Returns true if the given entity is in the Scene."]
    #[doc = ""]
    #[doc = " @return Whether the given entity is in the Scene."]
    #[link_name = "\u{1}_ZNK8filament5Scene9hasEntityEN5utils6EntityE"]
    pub fn filament_Scene_hasEntity(this: *const filament_Scene, entity: utils_Entity) -> bool;
}
impl filament_Scene {
    #[inline]
    pub unsafe fn setSkybox(&mut self, skybox: *mut filament_Skybox) {
        filament_Scene_setSkybox(self, skybox)
    }
    #[inline]
    pub unsafe fn setIndirectLight(&mut self, ibl: *const filament_IndirectLight) {
        filament_Scene_setIndirectLight(self, ibl)
    }
    #[inline]
    pub unsafe fn addEntity(&mut self, entity: utils_Entity) {
        filament_Scene_addEntity(self, entity)
    }
    #[inline]
    pub unsafe fn addEntities(&mut self, entities: *const utils_Entity, count: size_t) {
        filament_Scene_addEntities(self, entities, count)
    }
    #[inline]
    pub unsafe fn remove(&mut self, entity: utils_Entity) {
        filament_Scene_remove(self, entity)
    }
    #[inline]
    pub unsafe fn getRenderableCount(&self) -> size_t {
        filament_Scene_getRenderableCount(self)
    }
    #[inline]
    pub unsafe fn getLightCount(&self) -> size_t {
        filament_Scene_getLightCount(self)
    }
    #[inline]
    pub unsafe fn hasEntity(&self, entity: utils_Entity) -> bool {
        filament_Scene_hasEntity(self, entity)
    }
}
#[doc = " A View encompasses all the state needed for rendering a Scene."]
#[doc = ""]
#[doc = " Renderer::render() operates on View objects. These View objects specify important parameters"]
#[doc = " such as:"]
#[doc = "  - The Scene"]
#[doc = "  - The Camera"]
#[doc = "  - The Viewport"]
#[doc = "  - Some rendering parameters"]
#[doc = ""]
#[doc = " \\note"]
#[doc = " View instances are heavy objects that internally cache a lot of data needed for rendering."]
#[doc = " It is not advised for an application to use many View objects."]
#[doc = ""]
#[doc = " For example, in a game, a View could be used for the main scene and another one for the"]
#[doc = " game's user interface. More View instances could be used for creating special effects (e.g."]
#[doc = " a View is akin to a rendering pass)."]
#[doc = ""]
#[doc = ""]
#[doc = " @see Renderer, Scene, Camera, RenderTarget"]
#[repr(C)]
#[derive(Debug)]
pub struct filament_View {
    pub _address: u8,
}
pub use self::filament_backend_TargetBufferFlags as filament_View_TargetBufferFlags;
pub const filament_View_QualityLevel_LOW: filament_View_QualityLevel = 0;
pub const filament_View_QualityLevel_MEDIUM: filament_View_QualityLevel = 1;
pub const filament_View_QualityLevel_HIGH: filament_View_QualityLevel = 2;
pub const filament_View_QualityLevel_ULTRA: filament_View_QualityLevel = 3;
pub type filament_View_QualityLevel = u8;
pub const filament_View_BlendMode_OPAQUE: filament_View_BlendMode = 0;
pub const filament_View_BlendMode_TRANSLUCENT: filament_View_BlendMode = 1;
pub type filament_View_BlendMode = u8;
#[doc = " Dynamic resolution can be used to either reach a desired target frame rate"]
#[doc = " by lowering the resolution of a View, or to increase the quality when the"]
#[doc = " rendering is faster than the target frame rate."]
#[doc = ""]
#[doc = " This structure can be used to specify the minimum scale factor used when"]
#[doc = " lowering the resolution of a View, and the maximum scale factor used when"]
#[doc = " increasing the resolution for higher quality rendering. The scale factors"]
#[doc = " can be controlled on each X and Y axis independently. By default, all scale"]
#[doc = " factors are set to 1.0."]
#[doc = ""]
#[doc = " enabled:   enable or disables dynamic resolution on a View"]
#[doc = " homogeneousScaling: by default the system scales the major axis first. Set this to true"]
#[doc = "                     to force homogeneous scaling."]
#[doc = " minScale:  the minimum scale in X and Y this View should use"]
#[doc = " maxScale:  the maximum scale in X and Y this View should use"]
#[doc = " quality:   upscaling quality."]
#[doc = "            LOW: 1 bilinear tap, Medium: 4 bilinear taps, High: 9 bilinear taps (tent)"]
#[doc = ""]
#[doc = " \\note"]
#[doc = " Dynamic resolution is only supported on platforms where the time to render"]
#[doc = " a frame can be measured accurately. Dynamic resolution is currently only"]
#[doc = " supported on Android."]
#[doc = ""]
#[doc = " @see Renderer::FrameRateOptions"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct filament_View_DynamicResolutionOptions {
    #[doc = "!< minimum scale factors in x and y"]
    pub minScale: filament_math_float2,
    #[doc = "!< maximum scale factors in x and y"]
    pub maxScale: filament_math_float2,
    #[doc = "!< enable or disable dynamic resolution"]
    pub enabled: bool,
    #[doc = "!< set to true to force homogeneous scaling"]
    pub homogeneousScaling: bool,
    #[doc = "!< Upscaling quality"]
    pub quality: filament_View_QualityLevel,
}
#[test]
fn bindgen_test_layout_filament_View_DynamicResolutionOptions() {
    assert_eq!(
        ::std::mem::size_of::<filament_View_DynamicResolutionOptions>(),
        20usize,
        concat!(
            "Size of: ",
            stringify!(filament_View_DynamicResolutionOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<filament_View_DynamicResolutionOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(filament_View_DynamicResolutionOptions)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_View_DynamicResolutionOptions>())).minScale as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_View_DynamicResolutionOptions),
            "::",
            stringify!(minScale)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_View_DynamicResolutionOptions>())).maxScale as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_View_DynamicResolutionOptions),
            "::",
            stringify!(maxScale)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_View_DynamicResolutionOptions>())).enabled as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_View_DynamicResolutionOptions),
            "::",
            stringify!(enabled)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_View_DynamicResolutionOptions>())).homogeneousScaling
                as *const _ as usize
        },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_View_DynamicResolutionOptions),
            "::",
            stringify!(homogeneousScaling)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_View_DynamicResolutionOptions>())).quality as *const _
                as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_View_DynamicResolutionOptions),
            "::",
            stringify!(quality)
        )
    );
}
#[doc = " Options to control the bloom effect"]
#[doc = ""]
#[doc = " enabled:     Enable or disable the bloom post-processing effect. Disabled by default."]
#[doc = " levels:      Number of successive blurs to achieve the blur effect, the minimum is 3 and the"]
#[doc = "              maximum is 12. This value together with resolution influences the spread of the"]
#[doc = "              blur effect. This value can be silently reduced to accommodate the original"]
#[doc = "              image size."]
#[doc = " resolution:  Resolution of bloom's minor axis. The minimum value is 2^levels and the"]
#[doc = "              the maximum is lower of the original resolution and 4096. This parameter is"]
#[doc = "              silently clamped to the minimum and maximum."]
#[doc = "              It is highly recommended that this value be smaller than the target resolution"]
#[doc = "              after dynamic resolution is applied (horizontally and vertically)."]
#[doc = " strength:    how much of the bloom is added to the original image. Between 0 and 1."]
#[doc = " blendMode:   Whether the bloom effect is purely additive (false) or mixed with the original"]
#[doc = "              image (true)."]
#[doc = " anamorphism: Bloom's aspect ratio (x/y), for artistic purposes."]
#[doc = " threshold:   When enabled, a threshold at 1.0 is applied on the source image, this is"]
#[doc = "              useful for artistic reasons and is usually needed when a dirt texture is used."]
#[doc = " dirt:        A dirt/scratch/smudges texture (that can be RGB), which gets added to the"]
#[doc = "              bloom effect. Smudges are visible where bloom occurs. Threshold must be"]
#[doc = "              enabled for the dirt effect to work properly."]
#[doc = " dirtStrength: Strength of the dirt texture."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct filament_View_BloomOptions {
    #[doc = "!< user provided dirt texture"]
    pub dirt: *mut filament_Texture,
    #[doc = "!< strength of the dirt texture"]
    pub dirtStrength: f32,
    #[doc = "!< bloom's strength between 0.0 and 1.0"]
    pub strength: f32,
    #[doc = "!< resolution of minor axis (2^levels to 4096)"]
    pub resolution: u32,
    #[doc = "!< bloom x/y aspect-ratio (1/32 to 32)"]
    pub anamorphism: f32,
    #[doc = "!< number of blur levels (3 to 12)"]
    pub levels: u8,
    #[doc = "!< how the bloom effect is applied"]
    pub blendMode: filament_View_BloomOptions_BlendMode,
    #[doc = "!< whether to threshold the source"]
    pub threshold: bool,
    #[doc = "!< enable or disable bloom"]
    pub enabled: bool,
}
#[doc = "!< Bloom is modulated by the strength parameter and added to the scene"]
pub const filament_View_BloomOptions_BlendMode_ADD: filament_View_BloomOptions_BlendMode = 0;
#[doc = "!< Bloom is interpolated with the scene using the strength parameter"]
pub const filament_View_BloomOptions_BlendMode_INTERPOLATE: filament_View_BloomOptions_BlendMode =
    1;
pub type filament_View_BloomOptions_BlendMode = u8;
#[test]
fn bindgen_test_layout_filament_View_BloomOptions() {
    assert_eq!(
        ::std::mem::size_of::<filament_View_BloomOptions>(),
        32usize,
        concat!("Size of: ", stringify!(filament_View_BloomOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<filament_View_BloomOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(filament_View_BloomOptions))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<filament_View_BloomOptions>())).dirt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_View_BloomOptions),
            "::",
            stringify!(dirt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_View_BloomOptions>())).dirtStrength as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_View_BloomOptions),
            "::",
            stringify!(dirtStrength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_View_BloomOptions>())).strength as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_View_BloomOptions),
            "::",
            stringify!(strength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_View_BloomOptions>())).resolution as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_View_BloomOptions),
            "::",
            stringify!(resolution)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_View_BloomOptions>())).anamorphism as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_View_BloomOptions),
            "::",
            stringify!(anamorphism)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_View_BloomOptions>())).levels as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_View_BloomOptions),
            "::",
            stringify!(levels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_View_BloomOptions>())).blendMode as *const _ as usize
        },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_View_BloomOptions),
            "::",
            stringify!(blendMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_View_BloomOptions>())).threshold as *const _ as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_View_BloomOptions),
            "::",
            stringify!(threshold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_View_BloomOptions>())).enabled as *const _ as usize
        },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_View_BloomOptions),
            "::",
            stringify!(enabled)
        )
    );
}
#[doc = " Options to control fog in the scene"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct filament_View_FogOptions {
    #[doc = "!< distance in world units from the camera where the fog starts ( >= 0.0 )"]
    pub distance: f32,
    #[doc = "!< fog's maximum opacity between 0 and 1"]
    pub maximumOpacity: f32,
    #[doc = "!< fog's floor in world units"]
    pub height: f32,
    #[doc = "!< how fast fog dissipates with altitude"]
    pub heightFalloff: f32,
    #[doc = "!< fog's color (linear), see fogColorFromIbl"]
    pub color: filament_math_float3,
    #[doc = "!< fog's density at altitude given by 'height'"]
    pub density: f32,
    #[doc = "!< distance in world units from the camera where in-scattering starts"]
    pub inScatteringStart: f32,
    #[doc = "!< size of in-scattering (>=0 to activate). Good values are >> 1 (e.g. ~10 - 100)."]
    pub inScatteringSize: f32,
    #[doc = "!< Fog color will be modulated by the IBL color in the view direction."]
    pub fogColorFromIbl: bool,
    #[doc = "!< enable or disable fog"]
    pub enabled: bool,
}
#[test]
fn bindgen_test_layout_filament_View_FogOptions() {
    assert_eq!(
        ::std::mem::size_of::<filament_View_FogOptions>(),
        44usize,
        concat!("Size of: ", stringify!(filament_View_FogOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<filament_View_FogOptions>(),
        4usize,
        concat!("Alignment of ", stringify!(filament_View_FogOptions))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_View_FogOptions>())).distance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_View_FogOptions),
            "::",
            stringify!(distance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_View_FogOptions>())).maximumOpacity as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_View_FogOptions),
            "::",
            stringify!(maximumOpacity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<filament_View_FogOptions>())).height as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_View_FogOptions),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_View_FogOptions>())).heightFalloff as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_View_FogOptions),
            "::",
            stringify!(heightFalloff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<filament_View_FogOptions>())).color as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_View_FogOptions),
            "::",
            stringify!(color)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_View_FogOptions>())).density as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_View_FogOptions),
            "::",
            stringify!(density)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_View_FogOptions>())).inScatteringStart as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_View_FogOptions),
            "::",
            stringify!(inScatteringStart)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_View_FogOptions>())).inScatteringSize as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_View_FogOptions),
            "::",
            stringify!(inScatteringSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_View_FogOptions>())).fogColorFromIbl as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_View_FogOptions),
            "::",
            stringify!(fogColorFromIbl)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_View_FogOptions>())).enabled as *const _ as usize
        },
        41usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_View_FogOptions),
            "::",
            stringify!(enabled)
        )
    );
}
#[doc = " Structure used to set the precision of the color buffer and related quality settings."]
#[doc = ""]
#[doc = " @see setRenderQuality, getRenderQuality"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct filament_View_RenderQuality {
    #[doc = " Sets the quality of the HDR color buffer."]
    #[doc = ""]
    #[doc = " A quality of HIGH or ULTRA means using an RGB16F or RGBA16F color buffer. This means"]
    #[doc = " colors in the LDR range (0..1) have a 10 bit precision. A quality of LOW or MEDIUM means"]
    #[doc = " using an R11G11B10F opaque color buffer or an RGBA16F transparent color buffer. With"]
    #[doc = " R11G11B10F colors in the LDR range have a precision of either 6 bits (red and green"]
    #[doc = " channels) or 5 bits (blue channel)."]
    pub hdrColorBuffer: filament_View_QualityLevel,
}
#[test]
fn bindgen_test_layout_filament_View_RenderQuality() {
    assert_eq!(
        ::std::mem::size_of::<filament_View_RenderQuality>(),
        1usize,
        concat!("Size of: ", stringify!(filament_View_RenderQuality))
    );
    assert_eq!(
        ::std::mem::align_of::<filament_View_RenderQuality>(),
        1usize,
        concat!("Alignment of ", stringify!(filament_View_RenderQuality))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_View_RenderQuality>())).hdrColorBuffer as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_View_RenderQuality),
            "::",
            stringify!(hdrColorBuffer)
        )
    );
}
#[doc = " Options for Ambient Occlusion"]
#[doc = " @see setAmbientOcclusion()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct filament_View_AmbientOcclusionOptions {
    #[doc = "!< Ambient Occlusion radius in meters, between 0 and ~10."]
    pub radius: f32,
    #[doc = "!< Controls ambient occlusion's contrast. Must be positive."]
    pub power: f32,
    #[doc = "!< Self-occlusion bias in meters. Use to avoid self-occlusion. Between 0 and a few mm."]
    pub bias: f32,
    #[doc = "!< How each dimension of the AO buffer is scaled. Must be positive and <= 1."]
    pub resolution: f32,
    #[doc = "!< Strength of the Ambient Occlusion effect."]
    pub intensity: f32,
    #[doc = "!< affects # of samples used for AO."]
    pub quality: filament_View_QualityLevel,
}
#[test]
fn bindgen_test_layout_filament_View_AmbientOcclusionOptions() {
    assert_eq!(
        ::std::mem::size_of::<filament_View_AmbientOcclusionOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(filament_View_AmbientOcclusionOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<filament_View_AmbientOcclusionOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(filament_View_AmbientOcclusionOptions)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_View_AmbientOcclusionOptions>())).radius as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_View_AmbientOcclusionOptions),
            "::",
            stringify!(radius)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_View_AmbientOcclusionOptions>())).power as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_View_AmbientOcclusionOptions),
            "::",
            stringify!(power)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_View_AmbientOcclusionOptions>())).bias as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_View_AmbientOcclusionOptions),
            "::",
            stringify!(bias)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_View_AmbientOcclusionOptions>())).resolution as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_View_AmbientOcclusionOptions),
            "::",
            stringify!(resolution)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_View_AmbientOcclusionOptions>())).intensity as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_View_AmbientOcclusionOptions),
            "::",
            stringify!(intensity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_View_AmbientOcclusionOptions>())).quality as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_View_AmbientOcclusionOptions),
            "::",
            stringify!(quality)
        )
    );
}
#[doc = "!< No Ambient Occlusion"]
pub const filament_View_AmbientOcclusion_NONE: filament_View_AmbientOcclusion = 0;
#[doc = "!< Basic, sampling SSAO"]
pub const filament_View_AmbientOcclusion_SSAO: filament_View_AmbientOcclusion = 1;
#[doc = " List of available ambient occlusion techniques"]
pub type filament_View_AmbientOcclusion = u8;
#[doc = "!< no anti aliasing performed as part of post-processing"]
pub const filament_View_AntiAliasing_NONE: filament_View_AntiAliasing = 0;
#[doc = "!< FXAA is a low-quality but very efficient type of anti-aliasing. (default)."]
pub const filament_View_AntiAliasing_FXAA: filament_View_AntiAliasing = 1;
#[doc = " List of available post-processing anti-aliasing techniques."]
#[doc = " @see setAntiAliasing, getAntiAliasing, setSampleCount"]
pub type filament_View_AntiAliasing = u8;
#[doc = "!< No dithering"]
pub const filament_View_Dithering_NONE: filament_View_Dithering = 0;
#[doc = "!< Temporal dithering (default)"]
pub const filament_View_Dithering_TEMPORAL: filament_View_Dithering = 1;
#[doc = " List of available post-processing dithering techniques."]
pub type filament_View_Dithering = u8;
#[doc = "!< Linear tone mapping (i.e. no tone mapping)"]
pub const filament_View_ToneMapping_LINEAR: filament_View_ToneMapping = 0;
#[doc = "!< ACES tone mapping"]
pub const filament_View_ToneMapping_ACES: filament_View_ToneMapping = 1;
#[doc = " List of available tone-mapping operators"]
pub type filament_View_ToneMapping = u8;
#[test]
fn bindgen_test_layout_filament_View() {
    assert_eq!(
        ::std::mem::size_of::<filament_View>(),
        1usize,
        concat!("Size of: ", stringify!(filament_View))
    );
    assert_eq!(
        ::std::mem::align_of::<filament_View>(),
        1usize,
        concat!("Alignment of ", stringify!(filament_View))
    );
}
extern "C" {
    #[doc = " Activates or deactivates ambient occlusion."]
    #[doc = ""]
    #[doc = " @param ambientOcclusion Type of ambient occlusion to use."]
    #[link_name = "\u{1}_ZN8filament4View19setAmbientOcclusionENS0_16AmbientOcclusionE"]
    pub fn filament_View_setAmbientOcclusion(
        this: *mut filament_View,
        ambientOcclusion: filament_View_AmbientOcclusion,
    );
}
extern "C" {
    #[doc = " Queries the type of ambient occlusion active for this View."]
    #[doc = ""]
    #[doc = " @return ambient occlusion type."]
    #[link_name = "\u{1}_ZNK8filament4View19getAmbientOcclusionEv"]
    pub fn filament_View_getAmbientOcclusion(
        this: *const filament_View,
    ) -> filament_View_AmbientOcclusion;
}
extern "C" {
    #[doc = " Sets ambient occlusion options."]
    #[doc = ""]
    #[doc = " @param options Options for ambient occlusion."]
    #[link_name = "\u{1}_ZN8filament4View26setAmbientOcclusionOptionsERKNS0_23AmbientOcclusionOptionsE"]
    pub fn filament_View_setAmbientOcclusionOptions(
        this: *mut filament_View,
        options: *const filament_View_AmbientOcclusionOptions,
    );
}
extern "C" {
    #[doc = " Gets the ambient occlusion options."]
    #[doc = ""]
    #[doc = " @return ambient occlusion options currently set."]
    #[link_name = "\u{1}_ZNK8filament4View26getAmbientOcclusionOptionsEv"]
    pub fn filament_View_getAmbientOcclusionOptions(
        this: *const filament_View,
    ) -> *const filament_View_AmbientOcclusionOptions;
}
extern "C" {
    #[doc = " Sets the View's name. Only useful for debugging."]
    #[doc = " @param name Pointer to the View's name. The string is copied."]
    #[link_name = "\u{1}_ZN8filament4View7setNameEPKc"]
    pub fn filament_View_setName(this: *mut filament_View, name: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Returns the View's name"]
    #[doc = ""]
    #[doc = " @return a pointer owned by the View instance to the View's name."]
    #[doc = ""]
    #[doc = " @attention Do *not* free the pointer or modify its content."]
    #[link_name = "\u{1}_ZNK8filament4View7getNameEv"]
    pub fn filament_View_getName(this: *const filament_View) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Set this View instance's Scene."]
    #[doc = ""]
    #[doc = " @param scene Associate the specified Scene to this View. A Scene can be associated to"]
    #[doc = "              several View instances.\\n"]
    #[doc = "              \\p scene can be nullptr to dissociate the currently set Scene"]
    #[doc = "              from this View.\\n"]
    #[doc = "              The View doesn't take ownership of the Scene pointer (which"]
    #[doc = "              acts as a reference)."]
    #[doc = ""]
    #[doc = " @note"]
    #[doc = "  There is no reference-counting."]
    #[doc = "  Make sure to dissociate a Scene from all Views before destroying it."]
    #[link_name = "\u{1}_ZN8filament4View8setSceneEPNS_5SceneE"]
    pub fn filament_View_setScene(this: *mut filament_View, scene: *mut filament_Scene);
}
extern "C" {
    #[doc = " Returns the Scene currently associated with this View."]
    #[doc = " @return A pointer to the Scene associated to this View. nullptr if no Scene is set."]
    #[link_name = "\u{1}_ZN8filament4View8getSceneEv"]
    pub fn filament_View_getScene(this: *mut filament_View) -> *mut filament_Scene;
}
extern "C" {
    #[doc = " Sets this View's Camera."]
    #[doc = ""]
    #[doc = " @param camera    Associate the specified Camera to this View. A Camera can be associated to"]
    #[doc = "                  several View instances.\\n"]
    #[doc = "                  \\p camera can be nullptr to dissociate the currently set Camera from this"]
    #[doc = "                  View.\\n"]
    #[doc = "                  The View doesn't take ownership of the Camera pointer (which"]
    #[doc = "                  acts as a reference)."]
    #[doc = ""]
    #[doc = " @note"]
    #[doc = "  There is no reference-counting."]
    #[doc = "  Make sure to dissociate a Camera from all Views before destroying it."]
    #[link_name = "\u{1}_ZN8filament4View9setCameraEPNS_6CameraE"]
    pub fn filament_View_setCamera(this: *mut filament_View, camera: *mut filament_Camera);
}
extern "C" {
    #[doc = " Returns the Camera currently associated with this View."]
    #[doc = " @return A reference to the Camera associated to this View."]
    #[link_name = "\u{1}_ZN8filament4View9getCameraEv"]
    pub fn filament_View_getCamera(this: *mut filament_View) -> *mut filament_Camera;
}
extern "C" {
    #[doc = " Sets the rectangular region to render to."]
    #[doc = ""]
    #[doc = " The viewport specifies where the content of the View (i.e. the Scene) is rendered in"]
    #[doc = " the render target. The Render target is automatically clipped to the Viewport."]
    #[doc = ""]
    #[doc = " @param viewport  The Viewport to render the Scene into. The Viewport is a value-type, it is"]
    #[doc = "                  therefore copied. The parameter can be discarded after this call returns."]
    #[link_name = "\u{1}_ZN8filament4View11setViewportERKNS_8ViewportE"]
    pub fn filament_View_setViewport(this: *mut filament_View, viewport: *const filament_Viewport);
}
extern "C" {
    #[doc = " Returns the rectangular region that gets rendered to."]
    #[doc = " @return A constant reference to View's viewport."]
    #[link_name = "\u{1}_ZNK8filament4View11getViewportEv"]
    pub fn filament_View_getViewport(this: *const filament_View) -> *const filament_Viewport;
}
extern "C" {
    #[doc = " Sets the blending mode used to draw the view into the SwapChain."]
    #[doc = ""]
    #[doc = " @param blendMode either BlendMode::OPAQUE or BlendMode::TRANSLUCENT"]
    #[doc = " @see getBlendMode"]
    #[link_name = "\u{1}_ZN8filament4View12setBlendModeENS0_9BlendModeE"]
    pub fn filament_View_setBlendMode(this: *mut filament_View, blendMode: filament_View_BlendMode);
}
extern "C" {
    #[doc = " @return blending mode set by setBlendMode"]
    #[doc = " @see setBlendMode"]
    #[link_name = "\u{1}_ZNK8filament4View12getBlendModeEv"]
    pub fn filament_View_getBlendMode(this: *const filament_View) -> filament_View_BlendMode;
}
extern "C" {
    #[doc = " Sets which layers are visible."]
    #[doc = ""]
    #[doc = " Renderable objects can have one or several layers associated to them. Layers are"]
    #[doc = " represented with an 8-bits bitmask, where each bit corresponds to a layer."]
    #[doc = " @see RenderableManager::setLayerMask()."]
    #[doc = ""]
    #[doc = " This call sets which of those layers are visible. Renderables in invisible layers won't be"]
    #[doc = " rendered."]
    #[doc = ""]
    #[doc = " @param select    a bitmask specifying which layer to set or clear using \\p values."]
    #[doc = " @param values    a bitmask where each bit sets the visibility of the corresponding layer"]
    #[doc = "                  (1: visible, 0: invisible), only layers in \\p select are affected."]
    #[doc = ""]
    #[doc = " @note By default all layers are visible."]
    #[doc = " @note This is a convenient way to quickly show or hide sets of Renderable objects."]
    #[link_name = "\u{1}_ZN8filament4View16setVisibleLayersEhh"]
    pub fn filament_View_setVisibleLayers(this: *mut filament_View, select: u8, values: u8);
}
extern "C" {
    #[doc = " Enables or disables shadow mapping. Enabled by default."]
    #[doc = ""]
    #[doc = " @param enabled true enables shadow mapping, false disables it."]
    #[doc = ""]
    #[doc = " @see LightManager::Builder::castShadows(),"]
    #[doc = "      RenderableManager::Builder::receiveShadows(),"]
    #[doc = "      RenderableManager::Builder::castShadows(),"]
    #[link_name = "\u{1}_ZN8filament4View17setShadowsEnabledEb"]
    pub fn filament_View_setShadowsEnabled(this: *mut filament_View, enabled: bool);
}
extern "C" {
    #[doc = " Specifies an offscreen render target to render into."]
    #[doc = ""]
    #[doc = " By default, the view's associated render target is nullptr, which corresponds to the"]
    #[doc = " SwapChain associated with the engine."]
    #[doc = ""]
    #[doc = " @param renderTarget Render target associated with view, or nullptr for the swap chain."]
    #[link_name = "\u{1}_ZN8filament4View15setRenderTargetEPNS_12RenderTargetE"]
    pub fn filament_View_setRenderTarget(
        this: *mut filament_View,
        renderTarget: *mut filament_RenderTarget,
    );
}
extern "C" {
    #[doc = " Gets the offscreen render target associated with this view."]
    #[doc = ""]
    #[doc = " Returns nullptr if the render target is the swap chain (which is default)."]
    #[doc = ""]
    #[doc = " @see setRenderTarget"]
    #[link_name = "\u{1}_ZNK8filament4View15getRenderTargetEv"]
    pub fn filament_View_getRenderTarget(this: *const filament_View) -> *mut filament_RenderTarget;
}
extern "C" {
    #[doc = " Sets how many samples are to be used for MSAA in the post-process stage."]
    #[doc = " Default is 1 and disables MSAA."]
    #[doc = ""]
    #[doc = " @param count number of samples to use for multi-sampled anti-aliasing.\\n"]
    #[doc = "              0: treated as 1"]
    #[doc = "              1: no anti-aliasing"]
    #[doc = "              n: sample count. Effective sample could be different depending on the"]
    #[doc = "                 GPU capabilities."]
    #[doc = ""]
    #[doc = " @note Anti-aliasing can also be performed in the post-processing stage, generally at lower"]
    #[doc = "       cost. See setAntialiasing."]
    #[doc = ""]
    #[doc = " @see setAntialiasing"]
    #[link_name = "\u{1}_ZN8filament4View14setSampleCountEh"]
    pub fn filament_View_setSampleCount(this: *mut filament_View, count: u8);
}
extern "C" {
    #[doc = " Returns the sample count set by setSampleCount(). Effective sample count could be different."]
    #[doc = " A value of 0 or 1 means MSAA is disabled."]
    #[doc = ""]
    #[doc = " @return value set by setSampleCount()."]
    #[link_name = "\u{1}_ZNK8filament4View14getSampleCountEv"]
    pub fn filament_View_getSampleCount(this: *const filament_View) -> u8;
}
extern "C" {
    #[doc = " Enables or disables anti-aliasing in the post-processing stage. Enabled by default."]
    #[doc = " MSAA can be enabled in addition, see setSampleCount()."]
    #[doc = ""]
    #[doc = " @param type FXAA for enabling, NONE for disabling anti-aliasing."]
    #[doc = ""]
    #[doc = " @note For MSAA anti-aliasing, see setSamplerCount()."]
    #[doc = ""]
    #[doc = " @see setSampleCount"]
    #[link_name = "\u{1}_ZN8filament4View15setAntiAliasingENS0_12AntiAliasingE"]
    pub fn filament_View_setAntiAliasing(
        this: *mut filament_View,
        type_: filament_View_AntiAliasing,
    );
}
extern "C" {
    #[doc = " Queries whether anti-aliasing is enabled during the post-processing stage. To query"]
    #[doc = " whether MSAA is enabled, see getSampleCount()."]
    #[doc = ""]
    #[doc = " @return The post-processing anti-aliasing method."]
    #[link_name = "\u{1}_ZNK8filament4View15getAntiAliasingEv"]
    pub fn filament_View_getAntiAliasing(this: *const filament_View) -> filament_View_AntiAliasing;
}
extern "C" {
    #[doc = " Enables or disables tone-mapping in the post-processing stage. Enabled by default."]
    #[doc = ""]
    #[doc = " @param type Tone-mapping function."]
    #[link_name = "\u{1}_ZN8filament4View14setToneMappingENS0_11ToneMappingE"]
    pub fn filament_View_setToneMapping(this: *mut filament_View, type_: filament_View_ToneMapping);
}
extern "C" {
    #[doc = " Returns the tone-mapping function."]
    #[doc = " @return tone-mapping function."]
    #[link_name = "\u{1}_ZNK8filament4View14getToneMappingEv"]
    pub fn filament_View_getToneMapping(this: *const filament_View) -> filament_View_ToneMapping;
}
extern "C" {
    #[doc = " Enables or disables bloom in the post-processing stage. Disabled by default."]
    #[doc = ""]
    #[doc = " @param options options"]
    #[link_name = "\u{1}_ZN8filament4View15setBloomOptionsENS0_12BloomOptionsE"]
    pub fn filament_View_setBloomOptions(
        this: *mut filament_View,
        options: filament_View_BloomOptions,
    );
}
extern "C" {
    #[doc = " Enables or disables fog. Disabled by default."]
    #[doc = ""]
    #[doc = " @param options options"]
    #[link_name = "\u{1}_ZN8filament4View13setFogOptionsENS0_10FogOptionsE"]
    pub fn filament_View_setFogOptions(this: *mut filament_View, options: filament_View_FogOptions);
}
extern "C" {
    #[doc = " Queries the bloom options."]
    #[doc = ""]
    #[doc = " @return the current bloom options for this view."]
    #[link_name = "\u{1}_ZNK8filament4View15getBloomOptionsEv"]
    pub fn filament_View_getBloomOptions(this: *const filament_View) -> filament_View_BloomOptions;
}
extern "C" {
    #[doc = " Enables or disables dithering in the post-processing stage. Enabled by default."]
    #[doc = ""]
    #[doc = " @param dithering dithering type"]
    #[link_name = "\u{1}_ZN8filament4View12setDitheringENS0_9DitheringE"]
    pub fn filament_View_setDithering(this: *mut filament_View, dithering: filament_View_Dithering);
}
extern "C" {
    #[doc = " Queries whether dithering is enabled during the post-processing stage."]
    #[doc = ""]
    #[doc = " @return the current dithering type for this view."]
    #[link_name = "\u{1}_ZNK8filament4View12getDitheringEv"]
    pub fn filament_View_getDithering(this: *const filament_View) -> filament_View_Dithering;
}
extern "C" {
    #[doc = " Sets the dynamic resolution options for this view. Dynamic resolution options"]
    #[doc = " controls whether dynamic resolution is enabled, and if it is, how it behaves."]
    #[doc = ""]
    #[doc = " @param options The dynamic resolution options to use on this view"]
    #[link_name = "\u{1}_ZN8filament4View27setDynamicResolutionOptionsERKNS0_24DynamicResolutionOptionsE"]
    pub fn filament_View_setDynamicResolutionOptions(
        this: *mut filament_View,
        options: *const filament_View_DynamicResolutionOptions,
    );
}
extern "C" {
    #[doc = " Returns the dynamic resolution options associated with this view."]
    #[doc = " @return value set by setDynamicResolutionOptions()."]
    #[link_name = "\u{1}_ZNK8filament4View27getDynamicResolutionOptionsEv"]
    pub fn filament_View_getDynamicResolutionOptions(
        this: *const filament_View,
    ) -> filament_View_DynamicResolutionOptions;
}
extern "C" {
    #[doc = " Sets the rendering quality for this view. Refer to RenderQuality for more"]
    #[doc = " information about the different settings available."]
    #[doc = ""]
    #[doc = " @param renderQuality The render quality to use on this view"]
    #[link_name = "\u{1}_ZN8filament4View16setRenderQualityERKNS0_13RenderQualityE"]
    pub fn filament_View_setRenderQuality(
        this: *mut filament_View,
        renderQuality: *const filament_View_RenderQuality,
    );
}
extern "C" {
    #[doc = " Returns the render quality used by this view."]
    #[doc = " @return value set by setRenderQuality()."]
    #[link_name = "\u{1}_ZNK8filament4View16getRenderQualityEv"]
    pub fn filament_View_getRenderQuality(
        this: *const filament_View,
    ) -> filament_View_RenderQuality;
}
extern "C" {
    #[doc = " Sets options relative to dynamic lighting for this view."]
    #[doc = ""]
    #[doc = " @param zLightNear Distance from the camera where the lights are expected to shine."]
    #[doc = "                   This parameter can affect performance and is useful because depending"]
    #[doc = "                   on the scene, lights that shine close to the camera may not be"]
    #[doc = "                   visible -- in this case, using a larger value can improve performance."]
    #[doc = "                   e.g. when standing and looking straight, several meters of the ground"]
    #[doc = "                   isn't visible and if lights are expected to shine there, there is no"]
    #[doc = "                   point using a short zLightNear. (Default 5m)."]
    #[doc = ""]
    #[doc = " @param zLightFar Distance from the camera after which lights are not expected to be visible."]
    #[doc = "                  Similarly to zLightNear, setting this value properly can improve"]
    #[doc = "                  performance. (Default 100m)."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " Together zLightNear and zLightFar must be chosen so that the visible influence of lights"]
    #[doc = " is spread between these two values."]
    #[doc = ""]
    #[link_name = "\u{1}_ZN8filament4View25setDynamicLightingOptionsEff"]
    pub fn filament_View_setDynamicLightingOptions(
        this: *mut filament_View,
        zLightNear: f32,
        zLightFar: f32,
    );
}
extern "C" {
    #[doc = " Enables or disables post processing. Enabled by default."]
    #[doc = ""]
    #[doc = " Post-processing includes:"]
    #[doc = "  - Bloom"]
    #[doc = "  - Tone-mapping & gamma encoding"]
    #[doc = "  - Dithering"]
    #[doc = "  - MSAA"]
    #[doc = "  - FXAA"]
    #[doc = "  - Dynamic scaling"]
    #[doc = ""]
    #[doc = " Disabling post-processing forgoes color correctness as well as anti-aliasing and"]
    #[doc = " should only be used experimentally (e.g., for UI overlays)."]
    #[doc = ""]
    #[doc = " @param enabled true enables post processing, false disables it."]
    #[doc = ""]
    #[doc = " @see setBloomOptions, setToneMapping, setAntiAliasing, setDithering, setSampleCount"]
    #[link_name = "\u{1}_ZN8filament4View24setPostProcessingEnabledEb"]
    pub fn filament_View_setPostProcessingEnabled(this: *mut filament_View, enabled: bool);
}
extern "C" {
    #[doc = "! Returns true if post-processing is enabled. See setPostProcessingEnabled() for more info."]
    #[link_name = "\u{1}_ZNK8filament4View23isPostProcessingEnabledEv"]
    pub fn filament_View_isPostProcessingEnabled(this: *const filament_View) -> bool;
}
extern "C" {
    #[doc = " Inverts the winding order of front faces. By default front faces use a counter-clockwise"]
    #[doc = " winding order. When the winding order is inverted, front faces are faces with a clockwise"]
    #[doc = " winding order."]
    #[doc = ""]
    #[doc = " Changing the winding order will directly affect the culling mode in materials"]
    #[doc = " (see Material::getCullingMode())."]
    #[doc = ""]
    #[doc = " Inverting the winding order of front faces is useful when rendering mirrored reflections"]
    #[doc = " (water, mirror surfaces, front camera in AR, etc.)."]
    #[doc = ""]
    #[doc = " @param inverted True to invert front faces, false otherwise."]
    #[link_name = "\u{1}_ZN8filament4View27setFrontFaceWindingInvertedEb"]
    pub fn filament_View_setFrontFaceWindingInverted(this: *mut filament_View, inverted: bool);
}
extern "C" {
    #[doc = " Returns true if the winding order of front faces is inverted."]
    #[doc = " See setFrontFaceWindingInverted() for more information."]
    #[link_name = "\u{1}_ZNK8filament4View26isFrontFaceWindingInvertedEv"]
    pub fn filament_View_isFrontFaceWindingInverted(this: *const filament_View) -> bool;
}
extern "C" {
    #[doc = "! debugging: allows to entirely disable frustum culling. (culling enabled by default)."]
    #[link_name = "\u{1}_ZN8filament4View24setFrustumCullingEnabledEb"]
    pub fn filament_View_setFrustumCullingEnabled(this: *mut filament_View, culling: bool);
}
extern "C" {
    #[doc = "! debugging: returns whether frustum culling is enabled."]
    #[link_name = "\u{1}_ZNK8filament4View23isFrustumCullingEnabledEv"]
    pub fn filament_View_isFrustumCullingEnabled(this: *const filament_View) -> bool;
}
extern "C" {
    #[doc = "! debugging: sets the Camera used for rendering. It may be different from the culling camera."]
    #[link_name = "\u{1}_ZN8filament4View14setDebugCameraEPNS_6CameraE"]
    pub fn filament_View_setDebugCamera(this: *mut filament_View, camera: *mut filament_Camera);
}
extern "C" {
    #[doc = "! debugging: returns a Camera from the point of view of *the* dominant directional light used for shadowing."]
    #[link_name = "\u{1}_ZNK8filament4View25getDirectionalLightCameraEv"]
    pub fn filament_View_getDirectionalLightCamera(
        this: *const filament_View,
    ) -> *const filament_Camera;
}
impl filament_View {
    #[inline]
    pub unsafe fn setAmbientOcclusion(&mut self, ambientOcclusion: filament_View_AmbientOcclusion) {
        filament_View_setAmbientOcclusion(self, ambientOcclusion)
    }
    #[inline]
    pub unsafe fn getAmbientOcclusion(&self) -> filament_View_AmbientOcclusion {
        filament_View_getAmbientOcclusion(self)
    }
    #[inline]
    pub unsafe fn setAmbientOcclusionOptions(
        &mut self,
        options: *const filament_View_AmbientOcclusionOptions,
    ) {
        filament_View_setAmbientOcclusionOptions(self, options)
    }
    #[inline]
    pub unsafe fn getAmbientOcclusionOptions(
        &self,
    ) -> *const filament_View_AmbientOcclusionOptions {
        filament_View_getAmbientOcclusionOptions(self)
    }
    #[inline]
    pub unsafe fn setName(&mut self, name: *const ::std::os::raw::c_char) {
        filament_View_setName(self, name)
    }
    #[inline]
    pub unsafe fn getName(&self) -> *const ::std::os::raw::c_char {
        filament_View_getName(self)
    }
    #[inline]
    pub unsafe fn setScene(&mut self, scene: *mut filament_Scene) {
        filament_View_setScene(self, scene)
    }
    #[inline]
    pub unsafe fn getScene(&mut self) -> *mut filament_Scene {
        filament_View_getScene(self)
    }
    #[inline]
    pub unsafe fn setCamera(&mut self, camera: *mut filament_Camera) {
        filament_View_setCamera(self, camera)
    }
    #[inline]
    pub unsafe fn getCamera(&mut self) -> *mut filament_Camera {
        filament_View_getCamera(self)
    }
    #[inline]
    pub unsafe fn setViewport(&mut self, viewport: *const filament_Viewport) {
        filament_View_setViewport(self, viewport)
    }
    #[inline]
    pub unsafe fn getViewport(&self) -> *const filament_Viewport {
        filament_View_getViewport(self)
    }
    #[inline]
    pub unsafe fn setBlendMode(&mut self, blendMode: filament_View_BlendMode) {
        filament_View_setBlendMode(self, blendMode)
    }
    #[inline]
    pub unsafe fn getBlendMode(&self) -> filament_View_BlendMode {
        filament_View_getBlendMode(self)
    }
    #[inline]
    pub unsafe fn setVisibleLayers(&mut self, select: u8, values: u8) {
        filament_View_setVisibleLayers(self, select, values)
    }
    #[inline]
    pub unsafe fn setShadowsEnabled(&mut self, enabled: bool) {
        filament_View_setShadowsEnabled(self, enabled)
    }
    #[inline]
    pub unsafe fn setRenderTarget(&mut self, renderTarget: *mut filament_RenderTarget) {
        filament_View_setRenderTarget(self, renderTarget)
    }
    #[inline]
    pub unsafe fn getRenderTarget(&self) -> *mut filament_RenderTarget {
        filament_View_getRenderTarget(self)
    }
    #[inline]
    pub unsafe fn setSampleCount(&mut self, count: u8) {
        filament_View_setSampleCount(self, count)
    }
    #[inline]
    pub unsafe fn getSampleCount(&self) -> u8 {
        filament_View_getSampleCount(self)
    }
    #[inline]
    pub unsafe fn setAntiAliasing(&mut self, type_: filament_View_AntiAliasing) {
        filament_View_setAntiAliasing(self, type_)
    }
    #[inline]
    pub unsafe fn getAntiAliasing(&self) -> filament_View_AntiAliasing {
        filament_View_getAntiAliasing(self)
    }
    #[inline]
    pub unsafe fn setToneMapping(&mut self, type_: filament_View_ToneMapping) {
        filament_View_setToneMapping(self, type_)
    }
    #[inline]
    pub unsafe fn getToneMapping(&self) -> filament_View_ToneMapping {
        filament_View_getToneMapping(self)
    }
    #[inline]
    pub unsafe fn setBloomOptions(&mut self, options: filament_View_BloomOptions) {
        filament_View_setBloomOptions(self, options)
    }
    #[inline]
    pub unsafe fn setFogOptions(&mut self, options: filament_View_FogOptions) {
        filament_View_setFogOptions(self, options)
    }
    #[inline]
    pub unsafe fn getBloomOptions(&self) -> filament_View_BloomOptions {
        filament_View_getBloomOptions(self)
    }
    #[inline]
    pub unsafe fn setDithering(&mut self, dithering: filament_View_Dithering) {
        filament_View_setDithering(self, dithering)
    }
    #[inline]
    pub unsafe fn getDithering(&self) -> filament_View_Dithering {
        filament_View_getDithering(self)
    }
    #[inline]
    pub unsafe fn setDynamicResolutionOptions(
        &mut self,
        options: *const filament_View_DynamicResolutionOptions,
    ) {
        filament_View_setDynamicResolutionOptions(self, options)
    }
    #[inline]
    pub unsafe fn getDynamicResolutionOptions(&self) -> filament_View_DynamicResolutionOptions {
        filament_View_getDynamicResolutionOptions(self)
    }
    #[inline]
    pub unsafe fn setRenderQuality(&mut self, renderQuality: *const filament_View_RenderQuality) {
        filament_View_setRenderQuality(self, renderQuality)
    }
    #[inline]
    pub unsafe fn getRenderQuality(&self) -> filament_View_RenderQuality {
        filament_View_getRenderQuality(self)
    }
    #[inline]
    pub unsafe fn setDynamicLightingOptions(&mut self, zLightNear: f32, zLightFar: f32) {
        filament_View_setDynamicLightingOptions(self, zLightNear, zLightFar)
    }
    #[inline]
    pub unsafe fn setPostProcessingEnabled(&mut self, enabled: bool) {
        filament_View_setPostProcessingEnabled(self, enabled)
    }
    #[inline]
    pub unsafe fn isPostProcessingEnabled(&self) -> bool {
        filament_View_isPostProcessingEnabled(self)
    }
    #[inline]
    pub unsafe fn setFrontFaceWindingInverted(&mut self, inverted: bool) {
        filament_View_setFrontFaceWindingInverted(self, inverted)
    }
    #[inline]
    pub unsafe fn isFrontFaceWindingInverted(&self) -> bool {
        filament_View_isFrontFaceWindingInverted(self)
    }
    #[inline]
    pub unsafe fn setFrustumCullingEnabled(&mut self, culling: bool) {
        filament_View_setFrustumCullingEnabled(self, culling)
    }
    #[inline]
    pub unsafe fn isFrustumCullingEnabled(&self) -> bool {
        filament_View_isFrustumCullingEnabled(self)
    }
    #[inline]
    pub unsafe fn setDebugCamera(&mut self, camera: *mut filament_Camera) {
        filament_View_setDebugCamera(self, camera)
    }
    #[inline]
    pub unsafe fn getDirectionalLightCamera(&self) -> *const filament_Camera {
        filament_View_getDirectionalLightCamera(self)
    }
}
#[doc = " Texture"]
#[doc = ""]
#[doc = " The Texture class supports:"]
#[doc = "  - 2D textures"]
#[doc = "  - 3D textures"]
#[doc = "  - Cube maps"]
#[doc = "  - mip mapping"]
#[doc = ""]
#[doc = ""]
#[doc = " Creation and destruction"]
#[doc = " ========================"]
#[doc = ""]
#[doc = " A Texture object is created using the Texture::Builder and destroyed by calling"]
#[doc = " Engine::destroy(const Texture*)."]
#[doc = ""]
#[doc = " ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}"]
#[doc = "  filament::Engine* engine = filament::Engine::create();"]
#[doc = ""]
#[doc = "  filament::IndirectLight* texture = filament::Texture::Builder()"]
#[doc = "              .width(64)"]
#[doc = "              .height(64)"]
#[doc = "              .build(*engine);"]
#[doc = ""]
#[doc = "  engine->destroy(texture);"]
#[doc = " ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"]
#[doc = ""]
#[repr(C)]
#[derive(Debug)]
pub struct filament_Texture {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct filament_Texture_BuilderDetails {
    _unused: [u8; 0],
}
pub type filament_Texture_PixelBufferDescriptor = filament_backend_PixelBufferDescriptor;
pub use self::filament_backend_CompressedPixelDataType as filament_Texture_CompressedType;
pub use self::filament_backend_PixelDataFormat as filament_Texture_Format;
pub use self::filament_backend_PixelDataType as filament_Texture_Type;
pub use self::filament_backend_SamplerType as filament_Texture_Sampler;
pub use self::filament_backend_TextureCubemapFace as filament_Texture_CubemapFace;
pub use self::filament_backend_TextureFormat as filament_Texture_InternalFormat;
pub type filament_Texture_FaceOffsets = filament_backend_FaceOffsets;
pub use self::filament_backend_TextureSwizzle as filament_Texture_Swizzle;
pub use self::filament_backend_TextureUsage as filament_Texture_Usage;
#[doc = " Options for enviornment prefiltering into reflection map"]
#[doc = ""]
#[doc = " @see generatePrefilterMipmap()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct filament_Texture_PrefilterOptions {
    #[doc = "!< sample count used for filtering"]
    pub sampleCount: u16,
    #[doc = "!< whether the environment must be mirrored"]
    pub mirror: bool,
    pub reserved: [usize; 3usize],
}
#[test]
fn bindgen_test_layout_filament_Texture_PrefilterOptions() {
    assert_eq!(
        ::std::mem::size_of::<filament_Texture_PrefilterOptions>(),
        32usize,
        concat!("Size of: ", stringify!(filament_Texture_PrefilterOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<filament_Texture_PrefilterOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(filament_Texture_PrefilterOptions)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_Texture_PrefilterOptions>())).sampleCount as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_Texture_PrefilterOptions),
            "::",
            stringify!(sampleCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_Texture_PrefilterOptions>())).mirror as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_Texture_PrefilterOptions),
            "::",
            stringify!(mirror)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_Texture_PrefilterOptions>())).reserved as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_Texture_PrefilterOptions),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = "! Use Builder to construct a Texture object instance"]
#[repr(C)]
#[derive(Debug)]
pub struct filament_Texture_Builder {
    pub _base: filament_BuilderBase<filament_Texture_BuilderDetails>,
}
#[test]
fn bindgen_test_layout_filament_Texture_Builder() {
    assert_eq!(
        ::std::mem::size_of::<filament_Texture_Builder>(),
        8usize,
        concat!("Size of: ", stringify!(filament_Texture_Builder))
    );
    assert_eq!(
        ::std::mem::align_of::<filament_Texture_Builder>(),
        8usize,
        concat!("Alignment of ", stringify!(filament_Texture_Builder))
    );
}
extern "C" {
    #[doc = " Specifies the width in texels of the texture. Doesn't need to be a power-of-two."]
    #[doc = " @param width Width of the texture in texels (default: 1)."]
    #[doc = " @return This Builder, for chaining calls."]
    #[link_name = "\u{1}_ZN8filament7Texture7Builder5widthEj"]
    pub fn filament_Texture_Builder_width(
        this: *mut filament_Texture_Builder,
        width: u32,
    ) -> *mut filament_Texture_Builder;
}
extern "C" {
    #[doc = " Specifies the height in texels of the texture. Doesn't need to be a power-of-two."]
    #[doc = " @param height Height of the texture in texels (default: 1)."]
    #[doc = " @return This Builder, for chaining calls."]
    #[link_name = "\u{1}_ZN8filament7Texture7Builder6heightEj"]
    pub fn filament_Texture_Builder_height(
        this: *mut filament_Texture_Builder,
        height: u32,
    ) -> *mut filament_Texture_Builder;
}
extern "C" {
    #[doc = " Specifies the depth in texels of the texture. Doesn't need to be a power-of-two."]
    #[doc = " The depth controls the number of layers in a 2D array texture. Values greater than 1"]
    #[doc = " effectively create a 3D texture."]
    #[doc = " @param depth Depth of the texture in texels (default: 1)."]
    #[doc = " @return This Builder, for chaining calls."]
    #[doc = " @attention This Texture instance must use Sampler::SAMPLER_2D_ARRAY or it has no effect."]
    #[link_name = "\u{1}_ZN8filament7Texture7Builder5depthEj"]
    pub fn filament_Texture_Builder_depth(
        this: *mut filament_Texture_Builder,
        depth: u32,
    ) -> *mut filament_Texture_Builder;
}
extern "C" {
    #[doc = " Specifies the numbers of mip map levels."]
    #[doc = " This creates a mip-map pyramid. The maximum number of levels a texture can have is"]
    #[doc = " such that max(width, height, level) / 2^MAX_LEVELS = 1"]
    #[doc = " @param levels Number of mipmap levels for this texture."]
    #[doc = " @return This Builder, for chaining calls."]
    #[link_name = "\u{1}_ZN8filament7Texture7Builder6levelsEh"]
    pub fn filament_Texture_Builder_levels(
        this: *mut filament_Texture_Builder,
        levels: u8,
    ) -> *mut filament_Texture_Builder;
}
extern "C" {
    #[doc = " Specifies the type of sampler to use."]
    #[doc = " @param target Sampler type"]
    #[doc = " @return This Builder, for chaining calls."]
    #[doc = " @see Sampler"]
    #[link_name = "\u{1}_ZN8filament7Texture7Builder7samplerENS_7backend11SamplerTypeE"]
    pub fn filament_Texture_Builder_sampler(
        this: *mut filament_Texture_Builder,
        target: filament_Texture_Sampler,
    ) -> *mut filament_Texture_Builder;
}
extern "C" {
    #[doc = " Specifies the *internal* format of this texture."]
    #[doc = ""]
    #[doc = " The internal format specifies how texels are stored (which may be different from how"]
    #[doc = " they're specified in setImage()). InternalFormat specifies both the color components"]
    #[doc = " and the data type used."]
    #[doc = ""]
    #[doc = " @param format Format of the texture's texel."]
    #[doc = " @return This Builder, for chaining calls."]
    #[doc = " @see InternalFormat, setImage"]
    #[link_name = "\u{1}_ZN8filament7Texture7Builder6formatENS_7backend13TextureFormatE"]
    pub fn filament_Texture_Builder_format(
        this: *mut filament_Texture_Builder,
        format: filament_Texture_InternalFormat,
    ) -> *mut filament_Texture_Builder;
}
extern "C" {
    #[doc = " Specifies if the texture will be used as a render target attachment."]
    #[doc = ""]
    #[doc = " If the texture is potentially rendered into, it may require a different memory layout,"]
    #[doc = " which needs to be known during construction."]
    #[doc = ""]
    #[doc = " @param usage Defaults to Texture::Usage::DEFAULT; c.f. Texture::Usage::COLOR_ATTACHMENT."]
    #[doc = " @return This Builder, for chaining calls."]
    #[link_name = "\u{1}_ZN8filament7Texture7Builder5usageENS_7backend12TextureUsageE"]
    pub fn filament_Texture_Builder_usage(
        this: *mut filament_Texture_Builder,
        usage: filament_Texture_Usage,
    ) -> *mut filament_Texture_Builder;
}
extern "C" {
    #[doc = " Specifies how a texture's channels map to color components"]
    #[doc = ""]
    #[doc = " @param r  texture channel for red component"]
    #[doc = " @param g  texture channel for green component"]
    #[doc = " @param b  texture channel for blue component"]
    #[doc = " @param a  texture channel for alpha component"]
    #[doc = " @return This Builder, for chaining calls."]
    #[link_name = "\u{1}_ZN8filament7Texture7Builder7swizzleENS_7backend14TextureSwizzleES3_S3_S3_"]
    pub fn filament_Texture_Builder_swizzle(
        this: *mut filament_Texture_Builder,
        r: filament_Texture_Swizzle,
        g: filament_Texture_Swizzle,
        b: filament_Texture_Swizzle,
        a: filament_Texture_Swizzle,
    ) -> *mut filament_Texture_Builder;
}
extern "C" {
    #[doc = " Creates the Texture object and returns a pointer to it."]
    #[doc = ""]
    #[doc = " @param engine Reference to the filament::Engine to associate this Texture with."]
    #[doc = ""]
    #[doc = " @return pointer to the newly created object or nullptr if exceptions are disabled and"]
    #[doc = "         an error occurred."]
    #[doc = ""]
    #[doc = " @exception utils::PostConditionPanic if a runtime error occurred, such as running out of"]
    #[doc = "            memory or other resources."]
    #[doc = " @exception utils::PreConditionPanic if a parameter to a builder function was invalid."]
    #[link_name = "\u{1}_ZN8filament7Texture7Builder5buildERNS_6EngineE"]
    pub fn filament_Texture_Builder_build(
        this: *mut filament_Texture_Builder,
        engine: *mut filament_Engine,
    ) -> *mut filament_Texture;
}
extern "C" {
    #[link_name = "\u{1}_ZN8filament7Texture7Builder6importEl"]
    pub fn filament_Texture_Builder_import(
        this: *mut filament_Texture_Builder,
        id: isize,
    ) -> *mut filament_Texture_Builder;
}
extern "C" {
    #[link_name = "\u{1}_ZN8filament7Texture7BuilderC1Ev"]
    pub fn filament_Texture_Builder_Builder(this: *mut filament_Texture_Builder);
}
extern "C" {
    #[link_name = "\u{1}_ZN8filament7Texture7BuilderC1ERKS1_"]
    pub fn filament_Texture_Builder_Builder1(
        this: *mut filament_Texture_Builder,
        rhs: *const filament_Texture_Builder,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8filament7Texture7BuilderC1EOS1_"]
    pub fn filament_Texture_Builder_Builder2(
        this: *mut filament_Texture_Builder,
        rhs: *mut filament_Texture_Builder,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8filament7Texture7BuilderD1Ev"]
    pub fn filament_Texture_Builder_Builder_destructor(this: *mut filament_Texture_Builder);
}
impl filament_Texture_Builder {
    #[inline]
    pub unsafe fn width(&mut self, width: u32) -> *mut filament_Texture_Builder {
        filament_Texture_Builder_width(self, width)
    }
    #[inline]
    pub unsafe fn height(&mut self, height: u32) -> *mut filament_Texture_Builder {
        filament_Texture_Builder_height(self, height)
    }
    #[inline]
    pub unsafe fn depth(&mut self, depth: u32) -> *mut filament_Texture_Builder {
        filament_Texture_Builder_depth(self, depth)
    }
    #[inline]
    pub unsafe fn levels(&mut self, levels: u8) -> *mut filament_Texture_Builder {
        filament_Texture_Builder_levels(self, levels)
    }
    #[inline]
    pub unsafe fn sampler(
        &mut self,
        target: filament_Texture_Sampler,
    ) -> *mut filament_Texture_Builder {
        filament_Texture_Builder_sampler(self, target)
    }
    #[inline]
    pub unsafe fn format(
        &mut self,
        format: filament_Texture_InternalFormat,
    ) -> *mut filament_Texture_Builder {
        filament_Texture_Builder_format(self, format)
    }
    #[inline]
    pub unsafe fn usage(&mut self, usage: filament_Texture_Usage) -> *mut filament_Texture_Builder {
        filament_Texture_Builder_usage(self, usage)
    }
    #[inline]
    pub unsafe fn swizzle(
        &mut self,
        r: filament_Texture_Swizzle,
        g: filament_Texture_Swizzle,
        b: filament_Texture_Swizzle,
        a: filament_Texture_Swizzle,
    ) -> *mut filament_Texture_Builder {
        filament_Texture_Builder_swizzle(self, r, g, b, a)
    }
    #[inline]
    pub unsafe fn build(&mut self, engine: *mut filament_Engine) -> *mut filament_Texture {
        filament_Texture_Builder_build(self, engine)
    }
    #[inline]
    pub unsafe fn import(&mut self, id: isize) -> *mut filament_Texture_Builder {
        filament_Texture_Builder_import(self, id)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        filament_Texture_Builder_Builder(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(rhs: *const filament_Texture_Builder) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        filament_Texture_Builder_Builder1(__bindgen_tmp.as_mut_ptr(), rhs);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(rhs: *mut filament_Texture_Builder) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        filament_Texture_Builder_Builder2(__bindgen_tmp.as_mut_ptr(), rhs);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        filament_Texture_Builder_Builder_destructor(self)
    }
}
pub const filament_Texture_BASE_LEVEL: size_t = 0;
#[test]
fn bindgen_test_layout_filament_Texture() {
    assert_eq!(
        ::std::mem::size_of::<filament_Texture>(),
        1usize,
        concat!("Size of: ", stringify!(filament_Texture))
    );
    assert_eq!(
        ::std::mem::align_of::<filament_Texture>(),
        1usize,
        concat!("Alignment of ", stringify!(filament_Texture))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8filament7Texture24isTextureFormatSupportedERNS_6EngineENS_7backend13TextureFormatE"]
    pub fn filament_Texture_isTextureFormatSupported(
        engine: *mut filament_Engine,
        format: filament_Texture_InternalFormat,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN8filament7Texture22computeTextureDataSizeENS_7backend15PixelDataFormatENS1_13PixelDataTypeEmmm"]
    pub fn filament_Texture_computeTextureDataSize(
        format: filament_Texture_Format,
        type_: filament_Texture_Type,
        stride: size_t,
        height: size_t,
        alignment: size_t,
    ) -> size_t;
}
extern "C" {
    #[doc = " Returns the width of a 2D or 3D texture level"]
    #[doc = " @param level texture level."]
    #[doc = " @return Width in texel of the specified \\p level, clamped to 1."]
    #[doc = " @attention If this texture is using Sampler::SAMPLER_EXTERNAL, the dimension"]
    #[doc = " of the texture are unknown and this method always returns whatever was set on the Builder."]
    #[link_name = "\u{1}_ZNK8filament7Texture8getWidthEm"]
    pub fn filament_Texture_getWidth(this: *const filament_Texture, level: size_t) -> size_t;
}
extern "C" {
    #[doc = " Returns the height of a 2D or 3D texture level"]
    #[doc = " @param level texture level."]
    #[doc = " @return Height in texel of the specified \\p level, clamped to 1."]
    #[doc = " @attention If this texture is using Sampler::SAMPLER_EXTERNAL, the dimension"]
    #[doc = " of the texture are unknown and this method always returns whatever was set on the Builder."]
    #[link_name = "\u{1}_ZNK8filament7Texture9getHeightEm"]
    pub fn filament_Texture_getHeight(this: *const filament_Texture, level: size_t) -> size_t;
}
extern "C" {
    #[doc = " Returns the depth of a 3D texture level"]
    #[doc = " @param level texture level."]
    #[doc = " @return Depth in texel of the specified \\p level, clamped to 1."]
    #[doc = " @attention If this texture is using Sampler::SAMPLER_EXTERNAL, the dimension"]
    #[doc = " of the texture are unknown and this method always returns whatever was set on the Builder."]
    #[link_name = "\u{1}_ZNK8filament7Texture8getDepthEm"]
    pub fn filament_Texture_getDepth(this: *const filament_Texture, level: size_t) -> size_t;
}
extern "C" {
    #[doc = " Returns the maximum number of levels this texture can have."]
    #[doc = " @return maximum number of levels this texture can have."]
    #[doc = " @attention If this texture is using Sampler::SAMPLER_EXTERNAL, the dimension"]
    #[doc = " of the texture are unknown and this method always returns whatever was set on the Builder."]
    #[link_name = "\u{1}_ZNK8filament7Texture9getLevelsEv"]
    pub fn filament_Texture_getLevels(this: *const filament_Texture) -> size_t;
}
extern "C" {
    #[doc = " Return this texture Sampler as set by Builder::sampler()."]
    #[doc = " @return this texture Sampler as set by Builder::sampler()"]
    #[link_name = "\u{1}_ZNK8filament7Texture9getTargetEv"]
    pub fn filament_Texture_getTarget(this: *const filament_Texture) -> filament_Texture_Sampler;
}
extern "C" {
    #[doc = " Return this texture InternalFormat as set by Builder::format()."]
    #[doc = " @return this texture InternalFormat as set by Builder::format()."]
    #[link_name = "\u{1}_ZNK8filament7Texture9getFormatEv"]
    pub fn filament_Texture_getFormat(
        this: *const filament_Texture,
    ) -> filament_Texture_InternalFormat;
}
extern "C" {
    #[doc = " Specify the image of a 2D texture for a level."]
    #[doc = ""]
    #[doc = " @param engine    Engine this texture is associated to."]
    #[doc = " @param level     Level to set the image for."]
    #[doc = " @param buffer    Client-side buffer containing the image to set."]
    #[doc = ""]
    #[doc = " @attention \\p engine must be the instance passed to Builder::build()"]
    #[doc = " @attention \\p level must be less than getLevels()."]
    #[doc = " @attention \\p buffer's Texture::Format must match that of getFormat()."]
    #[doc = " @attention This Texture instance must use Sampler::SAMPLER_2D or"]
    #[doc = "            Sampler::SAMPLER_EXTERNAL. IF the later is specified"]
    #[doc = "            and external textures are supported by the driver implementation,"]
    #[doc = "            this method will have no effect, otherwise it will behave as if the"]
    #[doc = "            texture was specified with driver::SamplerType::SAMPLER_2D."]
    #[doc = ""]
    #[doc = " @note"]
    #[doc = " This is equivalent to calling:"]
    #[doc = " ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"]
    #[doc = " setImage(engine, level, 0, 0, getWidth(level), getHeight(level), buffer);"]
    #[doc = " ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"]
    #[doc = ""]
    #[doc = " @see Builder::sampler()"]
    #[link_name = "\u{1}_ZNK8filament7Texture8setImageERNS_6EngineEmONS_7backend21PixelBufferDescriptorE"]
    pub fn filament_Texture_setImage(
        this: *const filament_Texture,
        engine: *mut filament_Engine,
        level: size_t,
        buffer: *mut filament_Texture_PixelBufferDescriptor,
    );
}
extern "C" {
    #[doc = " Updates a sub-image of a 2D texture for a level."]
    #[doc = ""]
    #[doc = " @param engine    Engine this texture is associated to."]
    #[doc = " @param level     Level to set the image for."]
    #[doc = " @param xoffset   Left offset of the sub-region to update."]
    #[doc = " @param yoffset   Bottom offset of the sub-region to update."]
    #[doc = " @param width     Width of the sub-region to update."]
    #[doc = " @param height    Height of the sub-region to update."]
    #[doc = " @param buffer    Client-side buffer containing the image to set."]
    #[doc = ""]
    #[doc = " @attention \\p engine must be the instance passed to Builder::build()"]
    #[doc = " @attention \\p level must be less than getLevels()."]
    #[doc = " @attention \\p buffer's Texture::Format must match that of getFormat()."]
    #[doc = " @attention This Texture instance must use Sampler::SAMPLER_2D or"]
    #[doc = "            Sampler::SAMPLER_EXTERNAL. IF the later is specified"]
    #[doc = "            and external textures are supported by the driver implementation,"]
    #[doc = "            this method will have no effect, otherwise it will behave as if the"]
    #[doc = "            texture was specified with Sampler::SAMPLER_2D."]
    #[doc = ""]
    #[doc = " @see Builder::sampler()"]
    #[link_name = "\u{1}_ZNK8filament7Texture8setImageERNS_6EngineEmjjjjONS_7backend21PixelBufferDescriptorE"]
    pub fn filament_Texture_setImage1(
        this: *const filament_Texture,
        engine: *mut filament_Engine,
        level: size_t,
        xoffset: u32,
        yoffset: u32,
        width: u32,
        height: u32,
        buffer: *mut filament_Texture_PixelBufferDescriptor,
    );
}
extern "C" {
    #[doc = " Specify all six images of a cube map level."]
    #[doc = ""]
    #[doc = " This method follows exactly the OpenGL conventions."]
    #[doc = ""]
    #[doc = " @param engine        Engine this texture is associated to."]
    #[doc = " @param level         Level to set the image for."]
    #[doc = " @param buffer        Client-side buffer containing the images to set."]
    #[doc = " @param faceOffsets   Offsets in bytes into \\p buffer for all six images. The offsets"]
    #[doc = "                      are specified in the following order: +x, -x, +y, -y, +z, -z"]
    #[doc = ""]
    #[doc = " @attention \\p engine must be the instance passed to Builder::build()"]
    #[doc = " @attention \\p level must be less than getLevels()."]
    #[doc = " @attention \\p buffer's Texture::Format must match that of getFormat()."]
    #[doc = " @attention This Texture instance must use Sampler::SAMPLER_CUBEMAP or it has no effect"]
    #[doc = ""]
    #[doc = " @see Texture::CubemapFace, Builder::sampler()"]
    #[link_name = "\u{1}_ZNK8filament7Texture8setImageERNS_6EngineEmONS_7backend21PixelBufferDescriptorERKNS3_11FaceOffsetsE"]
    pub fn filament_Texture_setImage2(
        this: *const filament_Texture,
        engine: *mut filament_Engine,
        level: size_t,
        buffer: *mut filament_Texture_PixelBufferDescriptor,
        faceOffsets: *const filament_Texture_FaceOffsets,
    );
}
extern "C" {
    #[doc = " Specify the external image to associate with this Texture. Typically the external"]
    #[doc = " image is OS specific, and can be a video or camera frame."]
    #[doc = " There are many restrictions when using an external image as a texture, such as:"]
    #[doc = "   - only the level of detail (lod) 0 can be specified"]
    #[doc = "   - only nearest or linear filtering is supported"]
    #[doc = "   - the size and format of the texture is defined by the external image"]
    #[doc = ""]
    #[doc = " @param engine        Engine this texture is associated to."]
    #[doc = " @param image         An opaque handle to a platform specific image. Supported types are"]
    #[doc = "                      eglImageOES on Android and CVPixelBufferRef on iOS."]
    #[doc = ""]
    #[doc = "                      On iOS the following pixel formats are supported:"]
    #[doc = "                        - kCVPixelFormatType_32BGRA"]
    #[doc = "                        - kCVPixelFormatType_420YpCbCr8BiPlanarFullRange"]
    #[doc = ""]
    #[doc = " @attention \\p engine must be the instance passed to Builder::build()"]
    #[doc = " @attention This Texture instance must use Sampler::SAMPLER_EXTERNAL or it has no effect"]
    #[doc = ""]
    #[doc = " @see Builder::sampler()"]
    #[doc = ""]
    #[link_name = "\u{1}_ZN8filament7Texture16setExternalImageERNS_6EngineEPv"]
    pub fn filament_Texture_setExternalImage(
        this: *mut filament_Texture,
        engine: *mut filament_Engine,
        image: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Specify the external image and plane to associate with this Texture. Typically the external"]
    #[doc = " image is OS specific, and can be a video or camera frame. When using this method, the"]
    #[doc = " external image must be a planar type (such as a YUV camera frame). The plane parameter"]
    #[doc = " selects which image plane is bound to this texture."]
    #[doc = ""]
    #[doc = " A single external image can be bound to different Filament textures, with each texture"]
    #[doc = " associated with a separate plane:"]
    #[doc = ""]
    #[doc = " ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"]
    #[doc = " textureA->setExternalImage(engine, image, 0);"]
    #[doc = " textureB->setExternalImage(engine, image, 1);"]
    #[doc = " ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"]
    #[doc = ""]
    #[doc = " There are many restrictions when using an external image as a texture, such as:"]
    #[doc = "   - only the level of detail (lod) 0 can be specified"]
    #[doc = "   - only nearest or linear filtering is supported"]
    #[doc = "   - the size and format of the texture is defined by the external image"]
    #[doc = ""]
    #[doc = " @param engine        Engine this texture is associated to."]
    #[doc = " @param image         An opaque handle to a platform specific image. Supported types are"]
    #[doc = "                      eglImageOES on Android and CVPixelBufferRef on iOS."]
    #[doc = " @param plane         The plane index of the external image to associate with this texture."]
    #[doc = ""]
    #[doc = "                      This method is only meaningful on iOS with"]
    #[doc = "                      kCVPixelFormatType_420YpCbCr8BiPlanarFullRange images. On platforms"]
    #[doc = "                      other than iOS, this method is a no-op."]
    #[link_name = "\u{1}_ZN8filament7Texture16setExternalImageERNS_6EngineEPvm"]
    pub fn filament_Texture_setExternalImage1(
        this: *mut filament_Texture,
        engine: *mut filament_Engine,
        image: *mut ::std::os::raw::c_void,
        plane: size_t,
    );
}
extern "C" {
    #[doc = " Specify the external stream to associate with this Texture. Typically the external"]
    #[doc = " stream is OS specific, and can be a video or camera stream."]
    #[doc = " There are many restrictions when using an external stream as a texture, such as:"]
    #[doc = "   - only the level of detail (lod) 0 can be specified"]
    #[doc = "   - only nearest or linear filtering is supported"]
    #[doc = "   - the size and format of the texture is defined by the external stream"]
    #[doc = ""]
    #[doc = " @param engine        Engine this texture is associated to."]
    #[doc = " @param stream        A Stream object"]
    #[doc = ""]
    #[doc = " @attention \\p engine must be the instance passed to Builder::build()"]
    #[doc = " @attention This Texture instance must use Sampler::SAMPLER_EXTERNAL or it has no effect"]
    #[doc = ""]
    #[doc = " @see Builder::sampler(), Stream"]
    #[doc = ""]
    #[link_name = "\u{1}_ZN8filament7Texture17setExternalStreamERNS_6EngineEPNS_6StreamE"]
    pub fn filament_Texture_setExternalStream(
        this: *mut filament_Texture,
        engine: *mut filament_Engine,
        stream: *mut filament_Stream,
    );
}
extern "C" {
    #[doc = " Generates all the mipmap levels automatically. This requires the texture to have a"]
    #[doc = " color-renderable format."]
    #[doc = ""]
    #[doc = " @param engine        Engine this texture is associated to."]
    #[doc = ""]
    #[doc = " @attention \\p engine must be the instance passed to Builder::build()"]
    #[doc = " @attention This Texture instance must NOT use Sampler::SAMPLER_CUBEMAP or it has no effect"]
    #[link_name = "\u{1}_ZNK8filament7Texture15generateMipmapsERNS_6EngineE"]
    pub fn filament_Texture_generateMipmaps(
        this: *const filament_Texture,
        engine: *mut filament_Engine,
    );
}
extern "C" {
    #[doc = " Creates a reflection map from an environment map."]
    #[doc = ""]
    #[doc = " This is a utility function that replaces calls to Texture::setImage()."]
    #[doc = " The provided environment map is processed and all mipmap levels are populated. The"]
    #[doc = " processing is similar to the offline tool `cmgen` as a lower quality setting."]
    #[doc = ""]
    #[doc = " This function is intended to be used when the environment cannot be processed offline,"]
    #[doc = " for instance if it's generated at runtime."]
    #[doc = ""]
    #[doc = " The source data must obey to some constraints:"]
    #[doc = "   - the data type must be PixelDataFormat::RGB"]
    #[doc = "   - the data format must be one of"]
    #[doc = "          - PixelDataType::FLOAT"]
    #[doc = "          - PixelDataType::HALF"]
    #[doc = ""]
    #[doc = " The current texture must be a cubemap"]
    #[doc = ""]
    #[doc = " The reflections cubemap's internal format cannot be a compressed format."]
    #[doc = ""]
    #[doc = " The reflections cubemap's dimension must be a power-of-two."]
    #[doc = ""]
    #[doc = " @warning This operation is computationally intensive, especially with large environments and"]
    #[doc = "          is currently synchronous. Expect about 1ms for a 16x16 cubemap."]
    #[doc = ""]
    #[doc = " @param engine        Reference to the filament::Engine to associate this IndirectLight with."]
    #[doc = " @param buffer        Client-side buffer containing the images to set."]
    #[doc = " @param faceOffsets   Offsets in bytes into \\p buffer for all six images. The offsets"]
    #[doc = "                      are specified in the following order: +x, -x, +y, -y, +z, -z"]
    #[doc = " @param options       Optional parameter to controlling user-specified quality and options."]
    #[doc = ""]
    #[doc = " @exception utils::PreConditionPanic if the source data constraints are not respected."]
    #[doc = ""]
    #[link_name = "\u{1}_ZN8filament7Texture23generatePrefilterMipmapERNS_6EngineEONS_7backend21PixelBufferDescriptorERKNS3_11FaceOffsetsEPKNS0_16PrefilterOptionsE"]
    pub fn filament_Texture_generatePrefilterMipmap(
        this: *mut filament_Texture,
        engine: *mut filament_Engine,
        buffer: *mut filament_Texture_PixelBufferDescriptor,
        faceOffsets: *const filament_Texture_FaceOffsets,
        options: *const filament_Texture_PrefilterOptions,
    );
}
impl filament_Texture {
    #[inline]
    pub unsafe fn isTextureFormatSupported(
        engine: *mut filament_Engine,
        format: filament_Texture_InternalFormat,
    ) -> bool {
        filament_Texture_isTextureFormatSupported(engine, format)
    }
    #[inline]
    pub unsafe fn computeTextureDataSize(
        format: filament_Texture_Format,
        type_: filament_Texture_Type,
        stride: size_t,
        height: size_t,
        alignment: size_t,
    ) -> size_t {
        filament_Texture_computeTextureDataSize(format, type_, stride, height, alignment)
    }
    #[inline]
    pub unsafe fn getWidth(&self, level: size_t) -> size_t {
        filament_Texture_getWidth(self, level)
    }
    #[inline]
    pub unsafe fn getHeight(&self, level: size_t) -> size_t {
        filament_Texture_getHeight(self, level)
    }
    #[inline]
    pub unsafe fn getDepth(&self, level: size_t) -> size_t {
        filament_Texture_getDepth(self, level)
    }
    #[inline]
    pub unsafe fn getLevels(&self) -> size_t {
        filament_Texture_getLevels(self)
    }
    #[inline]
    pub unsafe fn getTarget(&self) -> filament_Texture_Sampler {
        filament_Texture_getTarget(self)
    }
    #[inline]
    pub unsafe fn getFormat(&self) -> filament_Texture_InternalFormat {
        filament_Texture_getFormat(self)
    }
    #[inline]
    pub unsafe fn setImage(
        &self,
        engine: *mut filament_Engine,
        level: size_t,
        buffer: *mut filament_Texture_PixelBufferDescriptor,
    ) {
        filament_Texture_setImage(self, engine, level, buffer)
    }
    #[inline]
    pub unsafe fn setImage1(
        &self,
        engine: *mut filament_Engine,
        level: size_t,
        xoffset: u32,
        yoffset: u32,
        width: u32,
        height: u32,
        buffer: *mut filament_Texture_PixelBufferDescriptor,
    ) {
        filament_Texture_setImage1(self, engine, level, xoffset, yoffset, width, height, buffer)
    }
    #[inline]
    pub unsafe fn setImage2(
        &self,
        engine: *mut filament_Engine,
        level: size_t,
        buffer: *mut filament_Texture_PixelBufferDescriptor,
        faceOffsets: *const filament_Texture_FaceOffsets,
    ) {
        filament_Texture_setImage2(self, engine, level, buffer, faceOffsets)
    }
    #[inline]
    pub unsafe fn setExternalImage(
        &mut self,
        engine: *mut filament_Engine,
        image: *mut ::std::os::raw::c_void,
    ) {
        filament_Texture_setExternalImage(self, engine, image)
    }
    #[inline]
    pub unsafe fn setExternalImage1(
        &mut self,
        engine: *mut filament_Engine,
        image: *mut ::std::os::raw::c_void,
        plane: size_t,
    ) {
        filament_Texture_setExternalImage1(self, engine, image, plane)
    }
    #[inline]
    pub unsafe fn setExternalStream(
        &mut self,
        engine: *mut filament_Engine,
        stream: *mut filament_Stream,
    ) {
        filament_Texture_setExternalStream(self, engine, stream)
    }
    #[inline]
    pub unsafe fn generateMipmaps(&self, engine: *mut filament_Engine) {
        filament_Texture_generateMipmaps(self, engine)
    }
    #[inline]
    pub unsafe fn generatePrefilterMipmap(
        &mut self,
        engine: *mut filament_Engine,
        buffer: *mut filament_Texture_PixelBufferDescriptor,
        faceOffsets: *const filament_Texture_FaceOffsets,
        options: *const filament_Texture_PrefilterOptions,
    ) {
        filament_Texture_generatePrefilterMipmap(self, engine, buffer, faceOffsets, options)
    }
}
#[doc = " TextureSampler defines how a texture is accessed."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct filament_TextureSampler {
    pub mSamplerParams: filament_backend_SamplerParams,
}
pub use self::filament_backend_SamplerCompareFunc as filament_TextureSampler_CompareFunc;
pub use self::filament_backend_SamplerCompareMode as filament_TextureSampler_CompareMode;
pub use self::filament_backend_SamplerMagFilter as filament_TextureSampler_MagFilter;
pub use self::filament_backend_SamplerMinFilter as filament_TextureSampler_MinFilter;
pub use self::filament_backend_SamplerWrapMode as filament_TextureSampler_WrapMode;
#[test]
fn bindgen_test_layout_filament_TextureSampler() {
    assert_eq!(
        ::std::mem::size_of::<filament_TextureSampler>(),
        4usize,
        concat!("Size of: ", stringify!(filament_TextureSampler))
    );
    assert_eq!(
        ::std::mem::align_of::<filament_TextureSampler>(),
        4usize,
        concat!("Alignment of ", stringify!(filament_TextureSampler))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_TextureSampler>())).mSamplerParams as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_TextureSampler),
            "::",
            stringify!(mSamplerParams)
        )
    );
}
#[doc = " Camera represents the eye through which the scene is viewed."]
#[doc = ""]
#[doc = " A Camera has a position and orientation and controls the projection and exposure parameters."]
#[doc = ""]
#[doc = " Creation and destruction"]
#[doc = " ========================"]
#[doc = ""]
#[doc = " Like all Filament objects, Camera can only be constructed on the heap, however, unlike most"]
#[doc = " Filament objects it doesn't require a builder and can be constructed directly"]
#[doc = " using Engine::createCamera(). At the very least, a projection must be defined"]
#[doc = " using setProjection(). In most case, the camera position also needs to be set."]
#[doc = ""]
#[doc = " A Camera object is destroyed using Engine::destroy(const Camera*)."]
#[doc = ""]
#[doc = " ~~~~~~~~~~~{.cpp}"]
#[doc = "  filament::Engine* engine = filament::Engine::create();"]
#[doc = ""]
#[doc = "  filament::Camera* myCamera = engine->createCamera();"]
#[doc = "  myCamera->setProjection(45, 16.0/9.0, 0.1, 1.0);"]
#[doc = "  myCamera->lookAt({0, 1.60, 1}, {0, 0, 0});"]
#[doc = "  engine->destroy(myCamera);"]
#[doc = " ~~~~~~~~~~~"]
#[doc = ""]
#[doc = ""]
#[doc = " Coordinate system"]
#[doc = " ================="]
#[doc = ""]
#[doc = " The camera coordinate system defines the *view space*. The camera points towards its -z axis"]
#[doc = " and is oriented such that its top side is in the direction of +y, and its right side in the"]
#[doc = " direction of +x."]
#[doc = ""]
#[doc = " @note"]
#[doc = " Since the *near* and *far* planes are defined by the distance from the camera,"]
#[doc = " their respective coordinates are -\\p distance(near) and -\\p distance(far)."]
#[doc = ""]
#[doc = " Clipping planes"]
#[doc = " ==============="]
#[doc = ""]
#[doc = " The camera defines six *clipping planes* which together create a *clipping volume*. The"]
#[doc = " geometry outside this volume is clipped."]
#[doc = ""]
#[doc = " The clipping volume can either be a box or a frustum depending on which projection is used,"]
#[doc = " respectively Projection.ORTHO or Projection.PERSPECTIVE. The six planes are specified either"]
#[doc = " directly or indirectly using setProjection()."]
#[doc = ""]
#[doc = " The six planes are:"]
#[doc = " - left"]
#[doc = " - right"]
#[doc = " - bottom"]
#[doc = " - top"]
#[doc = " - near"]
#[doc = " - far"]
#[doc = ""]
#[doc = " @note"]
#[doc = " To increase the depth-buffer precision, the *far* clipping plane is always assumed to be at"]
#[doc = " infinity for rendering. That is, it is not used to clip geometry during rendering."]
#[doc = " However, it is used during the culling phase (objects entirely behind the *far*"]
#[doc = " plane are culled)."]
#[doc = ""]
#[doc = ""]
#[doc = " Choosing the *near* plane distance"]
#[doc = " =================================="]
#[doc = ""]
#[doc = " The *near* plane distance greatly affects the depth-buffer resolution."]
#[doc = ""]
#[doc = " Example: Precision at 1m, 10m, 100m and 1Km for various near distances assuming a 32-bit float"]
#[doc = " depth-buffer"]
#[doc = ""]
#[doc = "    near (m)  |   1 m  |   10 m  |  100 m   |  1 Km"]
#[doc = "  -----------:|:------:|:-------:|:--------:|:--------:"]
#[doc = "      0.001   | 7.2e-5 |  0.0043 |  0.4624  |  48.58"]
#[doc = "      0.01    | 6.9e-6 |  0.0001 |  0.0430  |   4.62"]
#[doc = "      0.1     | 3.6e-7 |  7.0e-5 |  0.0072  |   0.43"]
#[doc = "      1.0     |    0   |  3.8e-6 |  0.0007  |   0.07"]
#[doc = ""]
#[doc = ""]
#[doc = "  As can be seen in the table above, the depth-buffer precision drops rapidly with the"]
#[doc = "  distance to the camera."]
#[doc = " Make sure to pick the highest *near* plane distance possible."]
#[doc = ""]
#[doc = ""]
#[doc = " Exposure"]
#[doc = " ========"]
#[doc = ""]
#[doc = " The Camera is also used to set the scene's exposure, just like with a real camera. The lights"]
#[doc = " intensity and the Camera exposure interact to produce the final scene's brightness."]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = " \\see Frustum, View"]
#[repr(C)]
#[derive(Debug)]
pub struct filament_Camera {
    pub _address: u8,
}
#[doc = "!< perspective projection, objects get smaller as they are farther"]
pub const filament_Camera_Projection_PERSPECTIVE: filament_Camera_Projection = 0;
#[doc = "!< orthonormal projection, preserves distances"]
pub const filament_Camera_Projection_ORTHO: filament_Camera_Projection = 1;
#[doc = "! Denotes the projection type used by this camera. \\see setProjection"]
pub type filament_Camera_Projection = i32;
#[doc = "!< the field-of-view angle is defined on the vertical axis"]
pub const filament_Camera_Fov_VERTICAL: filament_Camera_Fov = 0;
#[doc = "!< the field-of-view angle is defined on the horizontal axis"]
pub const filament_Camera_Fov_HORIZONTAL: filament_Camera_Fov = 1;
#[doc = "! Denotes a field-of-view direction. \\see setProjection"]
pub type filament_Camera_Fov = i32;
#[test]
fn bindgen_test_layout_filament_Camera() {
    assert_eq!(
        ::std::mem::size_of::<filament_Camera>(),
        1usize,
        concat!("Size of: ", stringify!(filament_Camera))
    );
    assert_eq!(
        ::std::mem::align_of::<filament_Camera>(),
        1usize,
        concat!("Alignment of ", stringify!(filament_Camera))
    );
}
extern "C" {
    #[doc = " Sets the projection matrix from a frustum defined by six planes."]
    #[doc = ""]
    #[doc = " @param projection    type of #Projection to use."]
    #[doc = ""]
    #[doc = " @param left      distance in world units from the camera to the left plane,"]
    #[doc = "                  at the near plane."]
    #[doc = "                  Precondition: \\p left != \\p right."]
    #[doc = ""]
    #[doc = " @param right     distance in world units from the camera to the right plane,"]
    #[doc = "                  at the near plane."]
    #[doc = "                  Precondition: \\p left != \\p right."]
    #[doc = ""]
    #[doc = " @param bottom    distance in world units from the camera to the bottom plane,"]
    #[doc = "                  at the near plane."]
    #[doc = "                  Precondition: \\p bottom != \\p top."]
    #[doc = ""]
    #[doc = " @param top       distance in world units from the camera to the top plane,"]
    #[doc = "                  at the near plane."]
    #[doc = "                  Precondition: \\p left != \\p right."]
    #[doc = ""]
    #[doc = " @param near      distance in world units from the camera to the near plane. The near plane's"]
    #[doc = "                  position in view space is z = -\\p near."]
    #[doc = "                  Precondition: \\p near > 0 for PROJECTION::PERSPECTIVE or"]
    #[doc = "                                \\p near != far for PROJECTION::ORTHO"]
    #[doc = ""]
    #[doc = " @param far       distance in world units from the camera to the far plane. The far plane's"]
    #[doc = "                  position in view space is z = -\\p far."]
    #[doc = "                  Precondition: \\p far > near for PROJECTION::PERSPECTIVE or"]
    #[doc = "                                \\p far != near for PROJECTION::ORTHO"]
    #[doc = ""]
    #[doc = " @attention these parameters are silently modified to meet the preconditions above."]
    #[doc = ""]
    #[doc = " @see Projection, Frustum"]
    #[link_name = "\u{1}_ZN8filament6Camera13setProjectionENS0_10ProjectionEdddddd"]
    pub fn filament_Camera_setProjection(
        this: *mut filament_Camera,
        projection: filament_Camera_Projection,
        left: f64,
        right: f64,
        bottom: f64,
        top: f64,
        near: f64,
        far: f64,
    );
}
extern "C" {
    #[doc = " Sets the projection matrix from the field-of-view."]
    #[doc = ""]
    #[doc = " @param fovInDegrees full field-of-view in degrees. 0 < \\p fov < 180."]
    #[doc = " @param aspect       aspect ratio \\f$ \\frac{width}{height} \\f$. \\p aspect > 0."]
    #[doc = " @param near         distance in world units from the camera to the near plane. \\p near > 0."]
    #[doc = " @param far          distance in world units from the camera to the far plane. \\p far > \\p near."]
    #[doc = " @param direction    direction of the \\p fovInDegrees parameter."]
    #[doc = ""]
    #[doc = " @see Fov."]
    #[link_name = "\u{1}_ZN8filament6Camera13setProjectionEddddNS0_3FovE"]
    pub fn filament_Camera_setProjection1(
        this: *mut filament_Camera,
        fovInDegrees: f64,
        aspect: f64,
        near: f64,
        far: f64,
        direction: filament_Camera_Fov,
    );
}
extern "C" {
    #[doc = " Sets the projection matrix from the focal length."]
    #[doc = ""]
    #[doc = " @param focalLength lens's focal length in millimeters. \\p focalLength > 0."]
    #[doc = " @param aspect      aspect ratio \\f$ \\frac{width}{height} \\f$. \\p aspect > 0."]
    #[doc = " @param near        distance in world units from the camera to the near plane. \\p near > 0."]
    #[doc = " @param far         distance in world units from the camera to the far plane. \\p far > \\p near."]
    #[link_name = "\u{1}_ZN8filament6Camera17setLensProjectionEdddd"]
    pub fn filament_Camera_setLensProjection(
        this: *mut filament_Camera,
        focalLength: f64,
        aspect: f64,
        near: f64,
        far: f64,
    );
}
extern "C" {
    #[doc = " Sets the projection matrix."]
    #[doc = ""]
    #[doc = " @param projection  custom projection matrix."]
    #[doc = " @param near        distance in world units from the camera to the near plane. \\p near > 0."]
    #[doc = " @param far         distance in world units from the camera to the far plane. \\p far > \\p near."]
    #[link_name = "\u{1}_ZN8filament6Camera19setCustomProjectionERKNS_4math7details6TMat44IdEEdd"]
    pub fn filament_Camera_setCustomProjection(
        this: *mut filament_Camera,
        projection: *const filament_math_mat4,
        near: f64,
        far: f64,
    );
}
extern "C" {
    #[doc = " Returns the projection matrix used for rendering."]
    #[doc = ""]
    #[doc = " The projection matrix used for rendering always has its far plane set to infinity. This"]
    #[doc = " it why it may differ from the matrix set through setProjection() or setLensProjection()."]
    #[doc = ""]
    #[doc = " @return The projection matrix used for rendering"]
    #[doc = ""]
    #[doc = " @see setProjection, setLensProjection, setCustomProjection, getCullingProjectionMatrix"]
    #[link_name = "\u{1}_ZNK8filament6Camera19getProjectionMatrixEv"]
    pub fn filament_Camera_getProjectionMatrix(
        this: *const filament_Camera,
    ) -> *const filament_math_mat4;
}
extern "C" {
    #[doc = " Returns the projection matrix used for culling (far plane is finite)."]
    #[doc = ""]
    #[doc = " @return The projection matrix set by setProjection or setLensProjection."]
    #[doc = ""]
    #[doc = " @see setProjection, setLensProjection, getProjectionMatrix"]
    #[link_name = "\u{1}_ZNK8filament6Camera26getCullingProjectionMatrixEv"]
    pub fn filament_Camera_getCullingProjectionMatrix(
        this: *const filament_Camera,
    ) -> *const filament_math_mat4;
}
extern "C" {
    #[doc = "! Returns the frustum's near plane"]
    #[link_name = "\u{1}_ZNK8filament6Camera7getNearEv"]
    pub fn filament_Camera_getNear(this: *const filament_Camera) -> f32;
}
extern "C" {
    #[doc = "! Returns the frustum's far plane used for culling"]
    #[link_name = "\u{1}_ZNK8filament6Camera13getCullingFarEv"]
    pub fn filament_Camera_getCullingFar(this: *const filament_Camera) -> f32;
}
extern "C" {
    #[doc = " Sets the camera's view matrix."]
    #[doc = ""]
    #[doc = " Helper method to set the camera's entity transform component."]
    #[doc = " It has the same effect as calling:"]
    #[doc = ""]
    #[doc = " ~~~~~~~~~~~{.cpp}"]
    #[doc = "  engine.getTransformManager().setTransform("]
    #[doc = "          engine.getTransformManager().getInstance(camera->getEntity()), view);"]
    #[doc = " ~~~~~~~~~~~"]
    #[doc = ""]
    #[doc = " @param view The camera position and orientation provided as a rigid transform matrix."]
    #[doc = ""]
    #[doc = " @note The Camera \"looks\" towards its -z axis"]
    #[doc = ""]
    #[doc = " @warning \\p view must be a rigid transform"]
    #[link_name = "\u{1}_ZN8filament6Camera14setModelMatrixERKNS_4math7details6TMat44IfEE"]
    pub fn filament_Camera_setModelMatrix(
        this: *mut filament_Camera,
        view: *const filament_math_mat4f,
    );
}
extern "C" {
    #[doc = " Sets the camera's view matrix"]
    #[doc = ""]
    #[doc = " @param eye       The position of the camera in world space."]
    #[doc = " @param center    The point in world space the camera is looking at."]
    #[doc = " @param up        A unit vector denoting the camera's \"up\" direction."]
    #[link_name = "\u{1}_ZN8filament6Camera6lookAtERKNS_4math7details5TVec3IfEES6_S6_"]
    pub fn filament_Camera_lookAt(
        this: *mut filament_Camera,
        eye: *const filament_math_float3,
        center: *const filament_math_float3,
        up: *const filament_math_float3,
    );
}
extern "C" {
    #[doc = " Sets the camera's view matrix, assuming up is along the y axis"]
    #[doc = ""]
    #[doc = " @param eye       The position of the camera in world space."]
    #[doc = " @param center    The point in world space the camera is looking at."]
    #[link_name = "\u{1}_ZN8filament6Camera6lookAtERKNS_4math7details5TVec3IfEES6_"]
    pub fn filament_Camera_lookAt1(
        this: *mut filament_Camera,
        eye: *const filament_math_float3,
        center: *const filament_math_float3,
    );
}
extern "C" {
    #[doc = " Returns the camera's model matrix"]
    #[doc = ""]
    #[doc = " Helper method to return the camera's entity transform component."]
    #[doc = " It has the same effect as calling:"]
    #[doc = ""]
    #[doc = " ~~~~~~~~~~~{.cpp}"]
    #[doc = "  engine.getTransformManager().getWorldTransform("]
    #[doc = "          engine.getTransformManager().getInstance(camera->getEntity()));"]
    #[doc = " ~~~~~~~~~~~"]
    #[doc = ""]
    #[doc = " @return The camera's pose in world space as a rigid transform. Parent transforms, if any,"]
    #[doc = " are taken into account."]
    #[link_name = "\u{1}_ZNK8filament6Camera14getModelMatrixEv"]
    pub fn filament_Camera_getModelMatrix(this: *const filament_Camera) -> filament_math_mat4f;
}
extern "C" {
    #[doc = "! Returns the camera's view matrix (inverse of the model matrix)"]
    #[link_name = "\u{1}_ZNK8filament6Camera13getViewMatrixEv"]
    pub fn filament_Camera_getViewMatrix(this: *const filament_Camera) -> filament_math_mat4f;
}
extern "C" {
    #[doc = "! Returns the camera's position in world space"]
    #[link_name = "\u{1}_ZNK8filament6Camera11getPositionEv"]
    pub fn filament_Camera_getPosition(this: *const filament_Camera) -> filament_math_float3;
}
extern "C" {
    #[doc = "! Returns the camera's normalized left vector"]
    #[link_name = "\u{1}_ZNK8filament6Camera13getLeftVectorEv"]
    pub fn filament_Camera_getLeftVector(this: *const filament_Camera) -> filament_math_float3;
}
extern "C" {
    #[doc = "! Returns the camera's normalized up vector"]
    #[link_name = "\u{1}_ZNK8filament6Camera11getUpVectorEv"]
    pub fn filament_Camera_getUpVector(this: *const filament_Camera) -> filament_math_float3;
}
extern "C" {
    #[doc = "! Returns the camera's forward vector"]
    #[link_name = "\u{1}_ZNK8filament6Camera16getForwardVectorEv"]
    pub fn filament_Camera_getForwardVector(this: *const filament_Camera) -> filament_math_float3;
}
extern "C" {
    #[doc = "! Returns the camera's field of view in degrees"]
    #[link_name = "\u{1}_ZNK8filament6Camera23getFieldOfViewInDegreesENS0_3FovE"]
    pub fn filament_Camera_getFieldOfViewInDegrees(
        this: *const filament_Camera,
        direction: filament_Camera_Fov,
    ) -> f32;
}
extern "C" {
    #[doc = "! Returns a Frustum object in world space"]
    #[link_name = "\u{1}_ZNK8filament6Camera10getFrustumEv"]
    pub fn filament_Camera_getFrustum(this: *const filament_Camera) -> Frustum;
}
extern "C" {
    #[doc = "! Returns the entity representing this camera"]
    #[link_name = "\u{1}_ZNK8filament6Camera9getEntityEv"]
    pub fn filament_Camera_getEntity(this: *const filament_Camera) -> utils_Entity;
}
extern "C" {
    #[doc = " Sets this camera's exposure (default is f/16, 1/125s, 100 ISO)"]
    #[doc = ""]
    #[doc = " The exposure ultimately controls the scene's brightness, just like with a real camera."]
    #[doc = " The default values provide adequate exposure for a camera placed outdoors on a sunny day"]
    #[doc = " with the sun at the zenith."]
    #[doc = ""]
    #[doc = " @param aperture      Aperture in f-stops, clamped between 0.5 and 64."]
    #[doc = "                      A lower \\p aperture value *increases* the exposure, leading to"]
    #[doc = "                      a brighter scene. Realistic values are between 0.95 and 32."]
    #[doc = ""]
    #[doc = " @param shutterSpeed  Shutter speed in seconds, clamped between 1/25,000 and 60."]
    #[doc = "                      A lower shutter speed increases the exposure. Realistic values are"]
    #[doc = "                      between 1/8000 and 30."]
    #[doc = ""]
    #[doc = " @param sensitivity   Sensitivity in ISO, clamped between 10 and 204,800."]
    #[doc = "                      A higher \\p sensitivity increases the exposure. Realistic values are"]
    #[doc = "                      between 50 and 25600."]
    #[doc = ""]
    #[doc = " @note"]
    #[doc = " With the default parameters, the scene must contain at least one Light of intensity"]
    #[doc = " similar to the sun (e.g.: a 100,000 lux directional light)."]
    #[doc = ""]
    #[doc = " @see LightManager, Exposure"]
    #[link_name = "\u{1}_ZN8filament6Camera11setExposureEfff"]
    pub fn filament_Camera_setExposure(
        this: *mut filament_Camera,
        aperture: f32,
        shutterSpeed: f32,
        sensitivity: f32,
    );
}
extern "C" {
    #[doc = "! returns this camera's aperture in f-stops"]
    #[link_name = "\u{1}_ZNK8filament6Camera11getApertureEv"]
    pub fn filament_Camera_getAperture(this: *const filament_Camera) -> f32;
}
extern "C" {
    #[doc = "! returns this camera's shutter speed in seconds"]
    #[link_name = "\u{1}_ZNK8filament6Camera15getShutterSpeedEv"]
    pub fn filament_Camera_getShutterSpeed(this: *const filament_Camera) -> f32;
}
extern "C" {
    #[doc = "! returns this camera's sensitivity in ISO"]
    #[link_name = "\u{1}_ZNK8filament6Camera14getSensitivityEv"]
    pub fn filament_Camera_getSensitivity(this: *const filament_Camera) -> f32;
}
extern "C" {
    #[doc = " Returns the inverse of a projection matrix."]
    #[doc = ""]
    #[doc = " \\param p the projection matrix to inverse"]
    #[doc = " \\returns the inverse of the projection matrix \\p p"]
    #[doc = ""]
    #[doc = " \\warning the projection matrix to invert must have one of the form below:"]
    #[doc = " - perspective projection"]
    #[doc = ""]
    #[doc = "      \\f$"]
    #[doc = "      \\left("]
    #[doc = "      \\begin{array}{cccc}"]
    #[doc = "      a & 0 & tx & 0 \\\\"]
    #[doc = "      0 & b & ty & 0 \\\\"]
    #[doc = "      0 & 0 & tz & c \\\\"]
    #[doc = "      0 & 0 & -1 & 0 \\\\"]
    #[doc = "      \\end{array}"]
    #[doc = "      \\right)"]
    #[doc = "      \\f$"]
    #[doc = ""]
    #[doc = " - orthographic projection"]
    #[doc = ""]
    #[doc = "      \\f$"]
    #[doc = "      \\left("]
    #[doc = "      \\begin{array}{cccc}"]
    #[doc = "      a & 0 & 0 & tx \\\\"]
    #[doc = "      0 & b & 0 & ty \\\\"]
    #[doc = "      0 & 0 & c & tz \\\\"]
    #[doc = "      0 & 0 & 0 & 1  \\\\"]
    #[doc = "      \\end{array}"]
    #[doc = "      \\right)"]
    #[doc = "      \\f$"]
    #[link_name = "\u{1}_ZN8filament6Camera17inverseProjectionERKNS_4math7details6TMat44IdEE"]
    pub fn filament_Camera_inverseProjection(p: *const filament_math_mat4) -> filament_math_mat4;
}
extern "C" {
    #[doc = " Returns the inverse of a projection matrix."]
    #[doc = " @see inverseProjection(const math::mat4&)"]
    #[link_name = "\u{1}_ZN8filament6Camera17inverseProjectionERKNS_4math7details6TMat44IfEE"]
    pub fn filament_Camera_inverseProjection1(p: *const filament_math_mat4f)
        -> filament_math_mat4f;
}
impl filament_Camera {
    #[inline]
    pub unsafe fn setProjection(
        &mut self,
        projection: filament_Camera_Projection,
        left: f64,
        right: f64,
        bottom: f64,
        top: f64,
        near: f64,
        far: f64,
    ) {
        filament_Camera_setProjection(self, projection, left, right, bottom, top, near, far)
    }
    #[inline]
    pub unsafe fn setProjection1(
        &mut self,
        fovInDegrees: f64,
        aspect: f64,
        near: f64,
        far: f64,
        direction: filament_Camera_Fov,
    ) {
        filament_Camera_setProjection1(self, fovInDegrees, aspect, near, far, direction)
    }
    #[inline]
    pub unsafe fn setLensProjection(&mut self, focalLength: f64, aspect: f64, near: f64, far: f64) {
        filament_Camera_setLensProjection(self, focalLength, aspect, near, far)
    }
    #[inline]
    pub unsafe fn setCustomProjection(
        &mut self,
        projection: *const filament_math_mat4,
        near: f64,
        far: f64,
    ) {
        filament_Camera_setCustomProjection(self, projection, near, far)
    }
    #[inline]
    pub unsafe fn getProjectionMatrix(&self) -> *const filament_math_mat4 {
        filament_Camera_getProjectionMatrix(self)
    }
    #[inline]
    pub unsafe fn getCullingProjectionMatrix(&self) -> *const filament_math_mat4 {
        filament_Camera_getCullingProjectionMatrix(self)
    }
    #[inline]
    pub unsafe fn getNear(&self) -> f32 {
        filament_Camera_getNear(self)
    }
    #[inline]
    pub unsafe fn getCullingFar(&self) -> f32 {
        filament_Camera_getCullingFar(self)
    }
    #[inline]
    pub unsafe fn setModelMatrix(&mut self, view: *const filament_math_mat4f) {
        filament_Camera_setModelMatrix(self, view)
    }
    #[inline]
    pub unsafe fn lookAt(
        &mut self,
        eye: *const filament_math_float3,
        center: *const filament_math_float3,
        up: *const filament_math_float3,
    ) {
        filament_Camera_lookAt(self, eye, center, up)
    }
    #[inline]
    pub unsafe fn lookAt1(
        &mut self,
        eye: *const filament_math_float3,
        center: *const filament_math_float3,
    ) {
        filament_Camera_lookAt1(self, eye, center)
    }
    #[inline]
    pub unsafe fn getModelMatrix(&self) -> filament_math_mat4f {
        filament_Camera_getModelMatrix(self)
    }
    #[inline]
    pub unsafe fn getViewMatrix(&self) -> filament_math_mat4f {
        filament_Camera_getViewMatrix(self)
    }
    #[inline]
    pub unsafe fn getPosition(&self) -> filament_math_float3 {
        filament_Camera_getPosition(self)
    }
    #[inline]
    pub unsafe fn getLeftVector(&self) -> filament_math_float3 {
        filament_Camera_getLeftVector(self)
    }
    #[inline]
    pub unsafe fn getUpVector(&self) -> filament_math_float3 {
        filament_Camera_getUpVector(self)
    }
    #[inline]
    pub unsafe fn getForwardVector(&self) -> filament_math_float3 {
        filament_Camera_getForwardVector(self)
    }
    #[inline]
    pub unsafe fn getFieldOfViewInDegrees(&self, direction: filament_Camera_Fov) -> f32 {
        filament_Camera_getFieldOfViewInDegrees(self, direction)
    }
    #[inline]
    pub unsafe fn getFrustum(&self) -> Frustum {
        filament_Camera_getFrustum(self)
    }
    #[inline]
    pub unsafe fn getEntity(&self) -> utils_Entity {
        filament_Camera_getEntity(self)
    }
    #[inline]
    pub unsafe fn setExposure(&mut self, aperture: f32, shutterSpeed: f32, sensitivity: f32) {
        filament_Camera_setExposure(self, aperture, shutterSpeed, sensitivity)
    }
    #[inline]
    pub unsafe fn getAperture(&self) -> f32 {
        filament_Camera_getAperture(self)
    }
    #[inline]
    pub unsafe fn getShutterSpeed(&self) -> f32 {
        filament_Camera_getShutterSpeed(self)
    }
    #[inline]
    pub unsafe fn getSensitivity(&self) -> f32 {
        filament_Camera_getSensitivity(self)
    }
    #[inline]
    pub unsafe fn inverseProjection(p: *const filament_math_mat4) -> filament_math_mat4 {
        filament_Camera_inverseProjection(p)
    }
    #[inline]
    pub unsafe fn inverseProjection1(p: *const filament_math_mat4f) -> filament_math_mat4f {
        filament_Camera_inverseProjection1(p)
    }
}
impl filament_VertexAttribute {
    pub const MORPH_POSITION_0: filament_VertexAttribute = filament_VertexAttribute::CUSTOM0;
}
impl filament_VertexAttribute {
    pub const MORPH_POSITION_1: filament_VertexAttribute = filament_VertexAttribute::CUSTOM1;
}
impl filament_VertexAttribute {
    pub const MORPH_POSITION_2: filament_VertexAttribute = filament_VertexAttribute::CUSTOM2;
}
impl filament_VertexAttribute {
    pub const MORPH_POSITION_3: filament_VertexAttribute = filament_VertexAttribute::CUSTOM3;
}
impl filament_VertexAttribute {
    pub const MORPH_TANGENTS_0: filament_VertexAttribute = filament_VertexAttribute::CUSTOM4;
}
impl filament_VertexAttribute {
    pub const MORPH_TANGENTS_1: filament_VertexAttribute = filament_VertexAttribute::CUSTOM5;
}
impl filament_VertexAttribute {
    pub const MORPH_TANGENTS_2: filament_VertexAttribute = filament_VertexAttribute::CUSTOM6;
}
impl filament_VertexAttribute {
    pub const MORPH_TANGENTS_3: filament_VertexAttribute = filament_VertexAttribute::CUSTOM7;
}
#[repr(u8)]
#[doc = " Vertex attribute types"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum filament_VertexAttribute {
    #[doc = "!< XYZ position (float3)"]
    POSITION = 0,
    #[doc = "!< tangent, bitangent and normal, encoded as a quaternion (float4)"]
    TANGENTS = 1,
    #[doc = "!< vertex color (float4)"]
    COLOR = 2,
    #[doc = "!< texture coordinates (float2)"]
    UV0 = 3,
    #[doc = "!< texture coordinates (float2)"]
    UV1 = 4,
    #[doc = "!< indices of 4 bones, as unsigned integers (uvec4)"]
    BONE_INDICES = 5,
    #[doc = "!< weights of the 4 bones (normalized float4)"]
    BONE_WEIGHTS = 6,
    CUSTOM0 = 8,
    CUSTOM1 = 9,
    CUSTOM2 = 10,
    CUSTOM3 = 11,
    CUSTOM4 = 12,
    CUSTOM5 = 13,
    CUSTOM6 = 14,
    CUSTOM7 = 15,
}
#[doc = " Holds a set of buffers that define the geometry of a Renderable."]
#[doc = ""]
#[doc = " The geometry of the Renderable itself is defined by a set of vertex attributes such as"]
#[doc = " position, color, normals, tangents, etc..."]
#[doc = ""]
#[doc = " There is no need to have a 1-to-1 mapping between attributes and buffer. A buffer can hold the"]
#[doc = " data of several attributes -- attributes are then referred as being \"interleaved\"."]
#[doc = ""]
#[doc = " The buffers themselves are GPU resources, therefore mutating their data can be relatively slow."]
#[doc = " For this reason, it is best to separate the constant data from the dynamic data into multiple"]
#[doc = " buffers."]
#[doc = ""]
#[doc = " It is possible, and even encouraged, to use a single vertex buffer for several Renderables."]
#[doc = ""]
#[doc = " @see IndexBuffer, RenderableManager"]
#[repr(C)]
#[derive(Debug)]
pub struct filament_VertexBuffer {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct filament_VertexBuffer_BuilderDetails {
    _unused: [u8; 0],
}
pub use self::filament_backend_ElementType as filament_VertexBuffer_AttributeType;
pub type filament_VertexBuffer_BufferDescriptor = filament_backend_BufferDescriptor;
#[repr(C)]
#[derive(Debug)]
pub struct filament_VertexBuffer_Builder {
    pub _base: filament_BuilderBase<filament_VertexBuffer_BuilderDetails>,
}
#[test]
fn bindgen_test_layout_filament_VertexBuffer_Builder() {
    assert_eq!(
        ::std::mem::size_of::<filament_VertexBuffer_Builder>(),
        8usize,
        concat!("Size of: ", stringify!(filament_VertexBuffer_Builder))
    );
    assert_eq!(
        ::std::mem::align_of::<filament_VertexBuffer_Builder>(),
        8usize,
        concat!("Alignment of ", stringify!(filament_VertexBuffer_Builder))
    );
}
extern "C" {
    #[doc = " Defines how many buffers will be created in this vertex buffer set. These buffers are"]
    #[doc = " later referenced by index from 0 to \\p bufferCount - 1."]
    #[doc = ""]
    #[doc = " This call is mandatory. The default is 0."]
    #[doc = ""]
    #[doc = " @param bufferCount Number of buffers in this vertex buffer set. The maximum value is 8."]
    #[doc = " @return A reference to this Builder for chaining calls."]
    #[link_name = "\u{1}_ZN8filament12VertexBuffer7Builder11bufferCountEh"]
    pub fn filament_VertexBuffer_Builder_bufferCount(
        this: *mut filament_VertexBuffer_Builder,
        bufferCount: u8,
    ) -> *mut filament_VertexBuffer_Builder;
}
extern "C" {
    #[doc = " Size of each buffer in the set in vertex."]
    #[doc = ""]
    #[doc = " @param vertexCount Number of vertices in each buffer in this set."]
    #[doc = " @return A reference to this Builder for chaining calls."]
    #[link_name = "\u{1}_ZN8filament12VertexBuffer7Builder11vertexCountEj"]
    pub fn filament_VertexBuffer_Builder_vertexCount(
        this: *mut filament_VertexBuffer_Builder,
        vertexCount: u32,
    ) -> *mut filament_VertexBuffer_Builder;
}
extern "C" {
    #[doc = " Sets up an attribute for this vertex buffer set."]
    #[doc = ""]
    #[doc = " Using \\p byteOffset and \\p byteStride, attributes can be interleaved in the same buffer."]
    #[doc = ""]
    #[doc = " @param attribute The attribute to set up."]
    #[doc = " @param bufferIndex  The index of the buffer containing the data for this attribute. Must"]
    #[doc = "                     be between 0 and bufferCount() - 1."]
    #[doc = " @param attributeType The type of the attribute data (e.g. byte, float3, etc...)"]
    #[doc = " @param byteOffset Offset in *bytes* into the buffer \\p bufferIndex"]
    #[doc = " @param byteStride Stride in *bytes* to the next element of this attribute. When set to"]
    #[doc = "                   zero the attribute size, as defined by \\p attributeType is used."]
    #[doc = ""]
    #[doc = " @return A reference to this Builder for chaining calls."]
    #[doc = ""]
    #[doc = " @warning VertexAttribute::TANGENTS must be specified as a quaternion and is how normals"]
    #[doc = "          are specified."]
    #[doc = ""]
    #[doc = " @see VertexAttribute"]
    #[doc = ""]
    #[doc = " This is a no-op if the \\p attribute is an invalid enum."]
    #[doc = " This is a no-op if the \\p bufferIndex is out of bounds."]
    #[doc = ""]
    #[link_name = "\u{1}_ZN8filament12VertexBuffer7Builder9attributeENS_15VertexAttributeEhNS_7backend11ElementTypeEjh"]
    pub fn filament_VertexBuffer_Builder_attribute(
        this: *mut filament_VertexBuffer_Builder,
        attribute: filament_VertexAttribute,
        bufferIndex: u8,
        attributeType: filament_VertexBuffer_AttributeType,
        byteOffset: u32,
        byteStride: u8,
    ) -> *mut filament_VertexBuffer_Builder;
}
extern "C" {
    #[doc = " Sets whether a given attribute should be normalized. By default attributes are not"]
    #[doc = " normalized. A normalized attribute is mapped between 0 and 1 in the shader. This applies"]
    #[doc = " only to integer types."]
    #[doc = ""]
    #[doc = " @param attribute Enum of the attribute to set the normalization flag to."]
    #[doc = " @param normalize true to automatically normalize the given attribute."]
    #[doc = " @return A reference to this Builder for chaining calls."]
    #[doc = ""]
    #[doc = " This is a no-op if the \\p attribute is an invalid enum."]
    #[link_name = "\u{1}_ZN8filament12VertexBuffer7Builder10normalizedENS_15VertexAttributeEb"]
    pub fn filament_VertexBuffer_Builder_normalized(
        this: *mut filament_VertexBuffer_Builder,
        attribute: filament_VertexAttribute,
        normalize: bool,
    ) -> *mut filament_VertexBuffer_Builder;
}
extern "C" {
    #[doc = " Creates the VertexBuffer object and returns a pointer to it."]
    #[doc = ""]
    #[doc = " @param engine Reference to the filament::Engine to associate this VertexBuffer with."]
    #[doc = ""]
    #[doc = " @return pointer to the newly created object or nullptr if exceptions are disabled and"]
    #[doc = "         an error occurred."]
    #[doc = ""]
    #[doc = " @exception utils::PostConditionPanic if a runtime error occurred, such as running out of"]
    #[doc = "            memory or other resources."]
    #[doc = " @exception utils::PreConditionPanic if a parameter to a builder function was invalid."]
    #[link_name = "\u{1}_ZN8filament12VertexBuffer7Builder5buildERNS_6EngineE"]
    pub fn filament_VertexBuffer_Builder_build(
        this: *mut filament_VertexBuffer_Builder,
        engine: *mut filament_Engine,
    ) -> *mut filament_VertexBuffer;
}
extern "C" {
    #[link_name = "\u{1}_ZN8filament12VertexBuffer7BuilderC1Ev"]
    pub fn filament_VertexBuffer_Builder_Builder(this: *mut filament_VertexBuffer_Builder);
}
extern "C" {
    #[link_name = "\u{1}_ZN8filament12VertexBuffer7BuilderC1ERKS1_"]
    pub fn filament_VertexBuffer_Builder_Builder1(
        this: *mut filament_VertexBuffer_Builder,
        rhs: *const filament_VertexBuffer_Builder,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8filament12VertexBuffer7BuilderC1EOS1_"]
    pub fn filament_VertexBuffer_Builder_Builder2(
        this: *mut filament_VertexBuffer_Builder,
        rhs: *mut filament_VertexBuffer_Builder,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8filament12VertexBuffer7BuilderD1Ev"]
    pub fn filament_VertexBuffer_Builder_Builder_destructor(
        this: *mut filament_VertexBuffer_Builder,
    );
}
impl filament_VertexBuffer_Builder {
    #[inline]
    pub unsafe fn bufferCount(&mut self, bufferCount: u8) -> *mut filament_VertexBuffer_Builder {
        filament_VertexBuffer_Builder_bufferCount(self, bufferCount)
    }
    #[inline]
    pub unsafe fn vertexCount(&mut self, vertexCount: u32) -> *mut filament_VertexBuffer_Builder {
        filament_VertexBuffer_Builder_vertexCount(self, vertexCount)
    }
    #[inline]
    pub unsafe fn attribute(
        &mut self,
        attribute: filament_VertexAttribute,
        bufferIndex: u8,
        attributeType: filament_VertexBuffer_AttributeType,
        byteOffset: u32,
        byteStride: u8,
    ) -> *mut filament_VertexBuffer_Builder {
        filament_VertexBuffer_Builder_attribute(
            self,
            attribute,
            bufferIndex,
            attributeType,
            byteOffset,
            byteStride,
        )
    }
    #[inline]
    pub unsafe fn normalized(
        &mut self,
        attribute: filament_VertexAttribute,
        normalize: bool,
    ) -> *mut filament_VertexBuffer_Builder {
        filament_VertexBuffer_Builder_normalized(self, attribute, normalize)
    }
    #[inline]
    pub unsafe fn build(&mut self, engine: *mut filament_Engine) -> *mut filament_VertexBuffer {
        filament_VertexBuffer_Builder_build(self, engine)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        filament_VertexBuffer_Builder_Builder(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(rhs: *const filament_VertexBuffer_Builder) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        filament_VertexBuffer_Builder_Builder1(__bindgen_tmp.as_mut_ptr(), rhs);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(rhs: *mut filament_VertexBuffer_Builder) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        filament_VertexBuffer_Builder_Builder2(__bindgen_tmp.as_mut_ptr(), rhs);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        filament_VertexBuffer_Builder_Builder_destructor(self)
    }
}
#[doc = "!< 2 bytes per component as half-floats (8 bytes per quat)"]
pub const filament_VertexBuffer_QuatType_HALF4: filament_VertexBuffer_QuatType = 0;
#[doc = "!< 2 bytes per component as normalized integers (8 bytes per quat)"]
pub const filament_VertexBuffer_QuatType_SHORT4: filament_VertexBuffer_QuatType = 1;
#[doc = "!< 4 bytes per component as floats (16 bytes per quat)"]
pub const filament_VertexBuffer_QuatType_FLOAT4: filament_VertexBuffer_QuatType = 2;
#[doc = " Specifies the quaternion type for the \"populateTangentQuaternions\" utility."]
pub type filament_VertexBuffer_QuatType = u32;
#[doc = " Specifies the parameters for the \"populateTangentQuaternions\" utility."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct filament_VertexBuffer_QuatTangentContext {
    #[doc = "!< desired quaternion type (required)"]
    pub quatType: filament_VertexBuffer_QuatType,
    #[doc = "!< number of quaternions (required)"]
    pub quatCount: size_t,
    #[doc = "!< pre-allocated output buffer (required)"]
    pub outBuffer: *mut ::std::os::raw::c_void,
    #[doc = "!< desired stride in bytes (optional)"]
    pub outStride: size_t,
    #[doc = "!< source normals (required)"]
    pub normals: *const filament_math_float3,
    #[doc = "!< normals stride in bytes (optional)"]
    pub normalsStride: size_t,
    #[doc = "!< source tangents (optional)"]
    pub tangents: *const filament_math_float4,
    #[doc = "!< tangents stride in bytes (optional)"]
    pub tangentsStride: size_t,
}
#[test]
fn bindgen_test_layout_filament_VertexBuffer_QuatTangentContext() {
    assert_eq!(
        ::std::mem::size_of::<filament_VertexBuffer_QuatTangentContext>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(filament_VertexBuffer_QuatTangentContext)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<filament_VertexBuffer_QuatTangentContext>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(filament_VertexBuffer_QuatTangentContext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_VertexBuffer_QuatTangentContext>())).quatType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_VertexBuffer_QuatTangentContext),
            "::",
            stringify!(quatType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_VertexBuffer_QuatTangentContext>())).quatCount
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_VertexBuffer_QuatTangentContext),
            "::",
            stringify!(quatCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_VertexBuffer_QuatTangentContext>())).outBuffer
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_VertexBuffer_QuatTangentContext),
            "::",
            stringify!(outBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_VertexBuffer_QuatTangentContext>())).outStride
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_VertexBuffer_QuatTangentContext),
            "::",
            stringify!(outStride)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_VertexBuffer_QuatTangentContext>())).normals as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_VertexBuffer_QuatTangentContext),
            "::",
            stringify!(normals)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_VertexBuffer_QuatTangentContext>())).normalsStride
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_VertexBuffer_QuatTangentContext),
            "::",
            stringify!(normalsStride)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_VertexBuffer_QuatTangentContext>())).tangents
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_VertexBuffer_QuatTangentContext),
            "::",
            stringify!(tangents)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_VertexBuffer_QuatTangentContext>())).tangentsStride
                as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_VertexBuffer_QuatTangentContext),
            "::",
            stringify!(tangentsStride)
        )
    );
}
#[test]
fn bindgen_test_layout_filament_VertexBuffer() {
    assert_eq!(
        ::std::mem::size_of::<filament_VertexBuffer>(),
        1usize,
        concat!("Size of: ", stringify!(filament_VertexBuffer))
    );
    assert_eq!(
        ::std::mem::align_of::<filament_VertexBuffer>(),
        1usize,
        concat!("Alignment of ", stringify!(filament_VertexBuffer))
    );
}
extern "C" {
    #[doc = " Returns the vertex count."]
    #[doc = " @return Number of vertices in this vertex buffer set."]
    #[link_name = "\u{1}_ZNK8filament12VertexBuffer14getVertexCountEv"]
    pub fn filament_VertexBuffer_getVertexCount(this: *const filament_VertexBuffer) -> size_t;
}
extern "C" {
    #[doc = " Asynchronously copy-initializes the specified buffer from the given buffer data."]
    #[doc = ""]
    #[doc = " @param engine Reference to the filament::Engine to associate this VertexBuffer with."]
    #[doc = " @param bufferIndex Index of the buffer to initialize. Must be between 0"]
    #[doc = "                    and Builder::bufferCount() - 1."]
    #[doc = " @param buffer A BufferDescriptor representing the data used to initialize the buffer at"]
    #[doc = "               index \\p bufferIndex. BufferDescriptor points to raw, untyped data that will"]
    #[doc = "               be copied as-is into the buffer."]
    #[doc = " @param byteOffset Offset in *bytes* into the buffer at index \\p bufferIndex of this vertex"]
    #[doc = "                   buffer set."]
    #[link_name = "\u{1}_ZN8filament12VertexBuffer11setBufferAtERNS_6EngineEhONS_7backend16BufferDescriptorEj"]
    pub fn filament_VertexBuffer_setBufferAt(
        this: *mut filament_VertexBuffer,
        engine: *mut filament_Engine,
        bufferIndex: u8,
        buffer: *mut filament_VertexBuffer_BufferDescriptor,
        byteOffset: u32,
    );
}
extern "C" {
    #[doc = " Convenience function that consumes normal vectors (and, optionally, tangent vectors) and"]
    #[doc = " produces quaternions that can be passed into a TANGENTS buffer."]
    #[doc = ""]
    #[doc = " The given output buffer must be preallocated with at least quatCount * outStride bytes."]
    #[doc = ""]
    #[doc = " Normals are required but tangents are optional, in which case this function tries to generate"]
    #[doc = " reasonable tangents. The given normals should be unit length."]
    #[doc = ""]
    #[doc = " If supplied, the tangent vectors should be unit length and should be orthogonal to the"]
    #[doc = " normals. The w component of the tangent is a sign (-1 or +1) indicating handedness of the"]
    #[doc = " basis."]
    #[doc = ""]
    #[doc = " @param ctx An initialized QuatTangentContext structure."]
    #[doc = ""]
    #[doc = " @deprecated Instead please use filament::geometry::SurfaceOrientation from libgeometry, it"]
    #[doc = " has additional capabilities and a daisy-chain API. Be sure to explicitly link libgeometry"]
    #[doc = " since its dependency might be removed in future versions of libfilament."]
    #[link_name = "\u{1}_ZN8filament12VertexBuffer26populateTangentQuaternionsERKNS0_18QuatTangentContextE"]
    pub fn filament_VertexBuffer_populateTangentQuaternions(
        ctx: *const filament_VertexBuffer_QuatTangentContext,
    );
}
impl filament_VertexBuffer {
    #[inline]
    pub unsafe fn getVertexCount(&self) -> size_t {
        filament_VertexBuffer_getVertexCount(self)
    }
    #[inline]
    pub unsafe fn setBufferAt(
        &mut self,
        engine: *mut filament_Engine,
        bufferIndex: u8,
        buffer: *mut filament_VertexBuffer_BufferDescriptor,
        byteOffset: u32,
    ) {
        filament_VertexBuffer_setBufferAt(self, engine, bufferIndex, buffer, byteOffset)
    }
    #[inline]
    pub unsafe fn populateTangentQuaternions(ctx: *const filament_VertexBuffer_QuatTangentContext) {
        filament_VertexBuffer_populateTangentQuaternions(ctx)
    }
}
#[doc = " A buffer containing vertex indices into a VertexBuffer. Indices can be 16 or 32 bit."]
#[doc = " The buffer itself is a GPU resource, therefore mutating the data can be relatively slow."]
#[doc = " Typically these buffers are constant."]
#[doc = ""]
#[doc = " It is possible, and even encouraged, to use a single index buffer for several Renderables."]
#[doc = ""]
#[doc = " @see VertexBuffer, RenderableManager"]
#[repr(C)]
#[derive(Debug)]
pub struct filament_IndexBuffer {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct filament_IndexBuffer_BuilderDetails {
    _unused: [u8; 0],
}
pub type filament_IndexBuffer_BufferDescriptor = filament_backend_BufferDescriptor;
#[doc = "!< 16-bit indices"]
pub const filament_IndexBuffer_IndexType_USHORT: filament_IndexBuffer_IndexType = 12;
#[doc = "!< 32-bit indices"]
pub const filament_IndexBuffer_IndexType_UINT: filament_IndexBuffer_IndexType = 17;
#[doc = " Type of the index buffer"]
pub type filament_IndexBuffer_IndexType = u8;
#[repr(C)]
#[derive(Debug)]
pub struct filament_IndexBuffer_Builder {
    pub _base: filament_BuilderBase<filament_IndexBuffer_BuilderDetails>,
}
#[test]
fn bindgen_test_layout_filament_IndexBuffer_Builder() {
    assert_eq!(
        ::std::mem::size_of::<filament_IndexBuffer_Builder>(),
        8usize,
        concat!("Size of: ", stringify!(filament_IndexBuffer_Builder))
    );
    assert_eq!(
        ::std::mem::align_of::<filament_IndexBuffer_Builder>(),
        8usize,
        concat!("Alignment of ", stringify!(filament_IndexBuffer_Builder))
    );
}
extern "C" {
    #[doc = " Size of the index buffer in elements."]
    #[doc = " @param indexCount Number of indices the IndexBuffer can hold."]
    #[doc = " @return A reference to this Builder for chaining calls."]
    #[link_name = "\u{1}_ZN8filament11IndexBuffer7Builder10indexCountEj"]
    pub fn filament_IndexBuffer_Builder_indexCount(
        this: *mut filament_IndexBuffer_Builder,
        indexCount: u32,
    ) -> *mut filament_IndexBuffer_Builder;
}
extern "C" {
    #[doc = " Type of the index buffer, 16-bit or 32-bit."]
    #[doc = " @param indexType Type of indices stored in the IndexBuffer."]
    #[doc = " @return A reference to this Builder for chaining calls."]
    #[link_name = "\u{1}_ZN8filament11IndexBuffer7Builder10bufferTypeENS0_9IndexTypeE"]
    pub fn filament_IndexBuffer_Builder_bufferType(
        this: *mut filament_IndexBuffer_Builder,
        indexType: filament_IndexBuffer_IndexType,
    ) -> *mut filament_IndexBuffer_Builder;
}
extern "C" {
    #[doc = " Creates the IndexBuffer object and returns a pointer to it. After creation, the index"]
    #[doc = " buffer is uninitialized. Use IndexBuffer::setBuffer() to initialized the IndexBuffer."]
    #[doc = ""]
    #[doc = " @param engine Reference to the filament::Engine to associate this IndexBuffer with."]
    #[doc = ""]
    #[doc = " @return pointer to the newly created object or nullptr if exceptions are disabled and"]
    #[doc = "         an error occurred."]
    #[doc = ""]
    #[doc = " @exception utils::PostConditionPanic if a runtime error occurred, such as running out of"]
    #[doc = "            memory or other resources."]
    #[doc = " @exception utils::PreConditionPanic if a parameter to a builder function was invalid."]
    #[doc = ""]
    #[doc = " @see IndexBuffer::setBuffer"]
    #[link_name = "\u{1}_ZN8filament11IndexBuffer7Builder5buildERNS_6EngineE"]
    pub fn filament_IndexBuffer_Builder_build(
        this: *mut filament_IndexBuffer_Builder,
        engine: *mut filament_Engine,
    ) -> *mut filament_IndexBuffer;
}
extern "C" {
    #[link_name = "\u{1}_ZN8filament11IndexBuffer7BuilderC1Ev"]
    pub fn filament_IndexBuffer_Builder_Builder(this: *mut filament_IndexBuffer_Builder);
}
extern "C" {
    #[link_name = "\u{1}_ZN8filament11IndexBuffer7BuilderC1ERKS1_"]
    pub fn filament_IndexBuffer_Builder_Builder1(
        this: *mut filament_IndexBuffer_Builder,
        rhs: *const filament_IndexBuffer_Builder,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8filament11IndexBuffer7BuilderC1EOS1_"]
    pub fn filament_IndexBuffer_Builder_Builder2(
        this: *mut filament_IndexBuffer_Builder,
        rhs: *mut filament_IndexBuffer_Builder,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8filament11IndexBuffer7BuilderD1Ev"]
    pub fn filament_IndexBuffer_Builder_Builder_destructor(this: *mut filament_IndexBuffer_Builder);
}
impl filament_IndexBuffer_Builder {
    #[inline]
    pub unsafe fn indexCount(&mut self, indexCount: u32) -> *mut filament_IndexBuffer_Builder {
        filament_IndexBuffer_Builder_indexCount(self, indexCount)
    }
    #[inline]
    pub unsafe fn bufferType(
        &mut self,
        indexType: filament_IndexBuffer_IndexType,
    ) -> *mut filament_IndexBuffer_Builder {
        filament_IndexBuffer_Builder_bufferType(self, indexType)
    }
    #[inline]
    pub unsafe fn build(&mut self, engine: *mut filament_Engine) -> *mut filament_IndexBuffer {
        filament_IndexBuffer_Builder_build(self, engine)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        filament_IndexBuffer_Builder_Builder(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(rhs: *const filament_IndexBuffer_Builder) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        filament_IndexBuffer_Builder_Builder1(__bindgen_tmp.as_mut_ptr(), rhs);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(rhs: *mut filament_IndexBuffer_Builder) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        filament_IndexBuffer_Builder_Builder2(__bindgen_tmp.as_mut_ptr(), rhs);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        filament_IndexBuffer_Builder_Builder_destructor(self)
    }
}
#[test]
fn bindgen_test_layout_filament_IndexBuffer() {
    assert_eq!(
        ::std::mem::size_of::<filament_IndexBuffer>(),
        1usize,
        concat!("Size of: ", stringify!(filament_IndexBuffer))
    );
    assert_eq!(
        ::std::mem::align_of::<filament_IndexBuffer>(),
        1usize,
        concat!("Alignment of ", stringify!(filament_IndexBuffer))
    );
}
extern "C" {
    #[doc = " Asynchronously copy-initializes a region of this IndexBuffer from the data provided."]
    #[doc = ""]
    #[doc = " @param engine Reference to the filament::Engine to associate this IndexBuffer with."]
    #[doc = " @param buffer A BufferDescriptor representing the data used to initialize the IndexBuffer."]
    #[doc = "               BufferDescriptor points to raw, untyped data that will be interpreted as"]
    #[doc = "               either 16-bit or 32-bits indices based on the Type of this IndexBuffer."]
    #[doc = " @param byteOffset Offset in *bytes* into the IndexBuffer"]
    #[link_name = "\u{1}_ZN8filament11IndexBuffer9setBufferERNS_6EngineEONS_7backend16BufferDescriptorEj"]
    pub fn filament_IndexBuffer_setBuffer(
        this: *mut filament_IndexBuffer,
        engine: *mut filament_Engine,
        buffer: *mut filament_IndexBuffer_BufferDescriptor,
        byteOffset: u32,
    );
}
extern "C" {
    #[doc = " Returns the size of this IndexBuffer in elements."]
    #[doc = " @return The number of indices the IndexBuffer holds."]
    #[link_name = "\u{1}_ZNK8filament11IndexBuffer13getIndexCountEv"]
    pub fn filament_IndexBuffer_getIndexCount(this: *const filament_IndexBuffer) -> size_t;
}
impl filament_IndexBuffer {
    #[inline]
    pub unsafe fn setBuffer(
        &mut self,
        engine: *mut filament_Engine,
        buffer: *mut filament_IndexBuffer_BufferDescriptor,
        byteOffset: u32,
    ) {
        filament_IndexBuffer_setBuffer(self, engine, buffer, byteOffset)
    }
    #[inline]
    pub unsafe fn getIndexCount(&self) -> size_t {
        filament_IndexBuffer_getIndexCount(self)
    }
}
#[doc = " TransformManager is used to add transform components to entities."]
#[doc = ""]
#[doc = " A Transform component gives an entity a position and orientation in space in the coordinate"]
#[doc = " space of its parent transform. The TransformManager takes care of computing the world-space"]
#[doc = " transform of each component (i.e. its transform relative to the root)."]
#[doc = ""]
#[doc = " Creation and destruction"]
#[doc = " ========================"]
#[doc = ""]
#[doc = " A transform component is created using TransformManager::create() and destroyed by calling"]
#[doc = " TransformManager::destroy()."]
#[doc = ""]
#[doc = " ~~~~~~~~~~~{.cpp}"]
#[doc = "  filament::Engine* engine = filament::Engine::create();"]
#[doc = "  utils::Entity object = utils::EntityManager.get().create();"]
#[doc = ""]
#[doc = "  auto& tcm = engine->getTransformManager();"]
#[doc = ""]
#[doc = "  // create the transform component"]
#[doc = "  tcm.create(object);"]
#[doc = ""]
#[doc = "  // set its transform"]
#[doc = "  auto i = tcm.getInstance(object);"]
#[doc = "  tcm.setTransform(i, mat4f::translation({ 0, 0, -1 }));"]
#[doc = ""]
#[doc = "  // destroy the transform component"]
#[doc = "  tcm.destroy(object);"]
#[doc = " ~~~~~~~~~~~"]
#[doc = ""]
#[repr(C)]
#[derive(Debug)]
pub struct filament_TransformManager {
    pub _address: u8,
}
pub type filament_TransformManager_Instance = u32;
#[repr(C)]
pub struct filament_TransformManager_children_iterator {
    pub mManager: *const filament_TransformManager,
    pub mInstance: filament_TransformManager_Instance,
}
#[test]
fn bindgen_test_layout_filament_TransformManager_children_iterator() {
    assert_eq!(
        ::std::mem::size_of::<filament_TransformManager_children_iterator>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(filament_TransformManager_children_iterator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<filament_TransformManager_children_iterator>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(filament_TransformManager_children_iterator)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_TransformManager_children_iterator>())).mManager
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_TransformManager_children_iterator),
            "::",
            stringify!(mManager)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<filament_TransformManager_children_iterator>())).mInstance
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(filament_TransformManager_children_iterator),
            "::",
            stringify!(mInstance)
        )
    );
}
#[test]
fn bindgen_test_layout_filament_TransformManager() {
    assert_eq!(
        ::std::mem::size_of::<filament_TransformManager>(),
        1usize,
        concat!("Size of: ", stringify!(filament_TransformManager))
    );
    assert_eq!(
        ::std::mem::align_of::<filament_TransformManager>(),
        1usize,
        concat!("Alignment of ", stringify!(filament_TransformManager))
    );
}
extern "C" {
    #[doc = " Returns whether a particular Entity is associated with a component of this TransformManager"]
    #[doc = " @param e An Entity."]
    #[doc = " @return true if this Entity has a component associated with this manager."]
    #[link_name = "\u{1}_ZNK8filament16TransformManager12hasComponentEN5utils6EntityE"]
    pub fn filament_TransformManager_hasComponent(
        this: *const filament_TransformManager,
        e: utils_Entity,
    ) -> bool;
}
extern "C" {
    #[doc = " Gets an Instance representing the transform component associated with the given Entity."]
    #[doc = " @param e An Entity."]
    #[doc = " @return An Instance object, which represents the transform component associated with the Entity e."]
    #[doc = " @note Use Instance::isValid() to make sure the component exists."]
    #[doc = " @see hasComponent()"]
    #[link_name = "\u{1}_ZNK8filament16TransformManager11getInstanceEN5utils6EntityE"]
    pub fn filament_TransformManager_getInstance(
        this: *const filament_TransformManager,
        e: utils_Entity,
    ) -> filament_TransformManager_Instance;
}
extern "C" {
    #[doc = " Creates a transform component and associate it with the given entity."]
    #[doc = " @param entity            An Entity to associate a transform component to."]
    #[doc = " @param parent            The Instance of the parent transform, or Instance{} if no parent."]
    #[doc = " @param localTransform    The transform to initialize the transform component with."]
    #[doc = "                          This is always relative to the parent."]
    #[doc = ""]
    #[doc = " If this component already exists on the given entity, it is first destroyed as if"]
    #[doc = " destroy(utils::Entity e) was called."]
    #[doc = ""]
    #[doc = " @see destroy()"]
    #[link_name = "\u{1}_ZN8filament16TransformManager6createEN5utils6EntityENS1_14EntityInstanceIS0_Lb0EEERKNS_4math7details6TMat44IfEE"]
    pub fn filament_TransformManager_create(
        this: *mut filament_TransformManager,
        entity: utils_Entity,
        parent: filament_TransformManager_Instance,
        localTransform: *const filament_math_mat4f,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8filament16TransformManager6createEN5utils6EntityENS1_14EntityInstanceIS0_Lb0EEE"]
    pub fn filament_TransformManager_create1(
        this: *mut filament_TransformManager,
        entity: utils_Entity,
        parent: filament_TransformManager_Instance,
    );
}
extern "C" {
    #[doc = " Destroys this component from the given entity, children are orphaned."]
    #[doc = " @param e An entity."]
    #[doc = ""]
    #[doc = " @note If this transform had children, these are orphaned, which means their local"]
    #[doc = " transform becomes a world transform. Usually it's nonsensical. It's recommended to make"]
    #[doc = " sure that a destroyed transform doesn't have children."]
    #[doc = ""]
    #[doc = " @see create()"]
    #[link_name = "\u{1}_ZN8filament16TransformManager7destroyEN5utils6EntityE"]
    pub fn filament_TransformManager_destroy(this: *mut filament_TransformManager, e: utils_Entity);
}
extern "C" {
    #[doc = " Re-parents an entity to a new one."]
    #[doc = " @param i             The instance of the transform component to re-parent"]
    #[doc = " @param newParent     The instance of the new parent transform"]
    #[doc = " @attention It is an error to re-parent an entity to a descendant and will cause undefined behaviour."]
    #[doc = " @see getInstance()"]
    #[link_name = "\u{1}_ZN8filament16TransformManager9setParentEN5utils14EntityInstanceIS0_Lb0EEES3_"]
    pub fn filament_TransformManager_setParent(
        this: *mut filament_TransformManager,
        i: filament_TransformManager_Instance,
        newParent: filament_TransformManager_Instance,
    );
}
extern "C" {
    #[doc = " Returns the parent of a transform component, or the null entity if it is a root."]
    #[doc = " @param i The instance of the transform component to query."]
    #[link_name = "\u{1}_ZNK8filament16TransformManager9getParentEN5utils14EntityInstanceIS0_Lb0EEE"]
    pub fn filament_TransformManager_getParent(
        this: *const filament_TransformManager,
        i: filament_TransformManager_Instance,
    ) -> utils_Entity;
}
extern "C" {
    #[doc = " Returns the number of children of a transform component."]
    #[doc = " @param i The instance of the transform component to query."]
    #[doc = " @return The number of children of the queried component."]
    #[link_name = "\u{1}_ZNK8filament16TransformManager13getChildCountEN5utils14EntityInstanceIS0_Lb0EEE"]
    pub fn filament_TransformManager_getChildCount(
        this: *const filament_TransformManager,
        i: filament_TransformManager_Instance,
    ) -> size_t;
}
extern "C" {
    #[doc = " Gets a list of children for a transform component."]
    #[doc = ""]
    #[doc = " @param i The instance of the transform component to query."]
    #[doc = " @param children Pointer to array-of-Entity. The array must have at least \"count\" elements."]
    #[doc = " @param count The maximum number of children to retrieve."]
    #[doc = " @return The number of children written to the pointer."]
    #[link_name = "\u{1}_ZNK8filament16TransformManager11getChildrenEN5utils14EntityInstanceIS0_Lb0EEEPNS1_6EntityEm"]
    pub fn filament_TransformManager_getChildren(
        this: *const filament_TransformManager,
        i: filament_TransformManager_Instance,
        children: *mut utils_Entity,
        count: size_t,
    ) -> size_t;
}
extern "C" {
    #[doc = " Returns an iterator to the Instance of the first child of the given parent."]
    #[doc = ""]
    #[doc = " @param parent Instance of the parent"]
    #[doc = " @return A forward iterator pointing to the first child of the given parent."]
    #[doc = ""]
    #[doc = " A child_iterator can only safely be dereferenced if it's different from getChildrenEnd(parent)"]
    #[link_name = "\u{1}_ZNK8filament16TransformManager16getChildrenBeginEN5utils14EntityInstanceIS0_Lb0EEE"]
    pub fn filament_TransformManager_getChildrenBegin(
        this: *const filament_TransformManager,
        parent: filament_TransformManager_Instance,
    ) -> filament_TransformManager_children_iterator;
}
extern "C" {
    #[doc = " Returns an undreferencable iterator representing the end of the children list"]
    #[doc = ""]
    #[doc = " @param parent Instance of the parent"]
    #[doc = " @return A forward iterator."]
    #[doc = ""]
    #[doc = " This iterator cannot be dereferenced"]
    #[link_name = "\u{1}_ZNK8filament16TransformManager14getChildrenEndEN5utils14EntityInstanceIS0_Lb0EEE"]
    pub fn filament_TransformManager_getChildrenEnd(
        this: *const filament_TransformManager,
        parent: filament_TransformManager_Instance,
    ) -> filament_TransformManager_children_iterator;
}
extern "C" {
    #[doc = " Sets a local transform of a transform component."]
    #[doc = " @param ci              The instance of the transform component to set the local transform to."]
    #[doc = " @param localTransform  The local transform (i.e. relative to the parent)."]
    #[doc = " @see getTransform()"]
    #[doc = " @attention This operation can be slow if the hierarchy of transform is too deep, and this"]
    #[doc = "            will be particularly bad when updating a lot of transforms. In that case,"]
    #[doc = "            consider using openLocalTransformTransaction() / commitLocalTransformTransaction()."]
    #[link_name = "\u{1}_ZN8filament16TransformManager12setTransformEN5utils14EntityInstanceIS0_Lb0EEERKNS_4math7details6TMat44IfEE"]
    pub fn filament_TransformManager_setTransform(
        this: *mut filament_TransformManager,
        ci: filament_TransformManager_Instance,
        localTransform: *const filament_math_mat4f,
    );
}
extern "C" {
    #[doc = " Returns the local transform of a transform component."]
    #[doc = " @param ci The instance of the transform component to query the local transform from."]
    #[doc = " @return The local transform of the component (i.e. relative to the parent). This always"]
    #[doc = "         returns the value set by setTransform()."]
    #[doc = " @see setTransform()"]
    #[link_name = "\u{1}_ZNK8filament16TransformManager12getTransformEN5utils14EntityInstanceIS0_Lb0EEE"]
    pub fn filament_TransformManager_getTransform(
        this: *const filament_TransformManager,
        ci: filament_TransformManager_Instance,
    ) -> *const filament_math_mat4f;
}
extern "C" {
    #[doc = " Return the world transform of a transform component."]
    #[doc = " @param ci The instance of the transform component to query the world transform from."]
    #[doc = " @return The world transform of the component (i.e. relative to the root). This is the"]
    #[doc = "         composition of this component's local transform with its parent's world transform."]
    #[doc = " @see setTransform()"]
    #[link_name = "\u{1}_ZNK8filament16TransformManager17getWorldTransformEN5utils14EntityInstanceIS0_Lb0EEE"]
    pub fn filament_TransformManager_getWorldTransform(
        this: *const filament_TransformManager,
        ci: filament_TransformManager_Instance,
    ) -> *const filament_math_mat4f;
}
extern "C" {
    #[doc = " Opens a local transform transaction. During a transaction, getWorldTransform() can"]
    #[doc = " return an invalid transform until commitLocalTransformTransaction() is called. However,"]
    #[doc = " setTransform() will perform significantly better and in constant time."]
    #[doc = ""]
    #[doc = " This is useful when updating many transforms and the transform hierarchy is deep (say more"]
    #[doc = " than 4 or 5 levels)."]
    #[doc = ""]
    #[doc = " @note If the local transform transaction is already open, this is a no-op."]
    #[doc = ""]
    #[doc = " @see commitLocalTransformTransaction(), setTransform()"]
    #[link_name = "\u{1}_ZN8filament16TransformManager29openLocalTransformTransactionEv"]
    pub fn filament_TransformManager_openLocalTransformTransaction(
        this: *mut filament_TransformManager,
    );
}
extern "C" {
    #[doc = " Commits the currently open local transform transaction. When this returns, calls"]
    #[doc = " to getWorldTransform() will return the proper value."]
    #[doc = ""]
    #[doc = " @attention failing to call this method when done updating the local transform will cause"]
    #[doc = "            a lot of rendering problems. The system never closes the transaction"]
    #[doc = "            automatically."]
    #[doc = ""]
    #[doc = " @note If the local transform transaction is not open, this is a no-op."]
    #[doc = ""]
    #[doc = " @see openLocalTransformTransaction(), setTransform()"]
    #[link_name = "\u{1}_ZN8filament16TransformManager31commitLocalTransformTransactionEv"]
    pub fn filament_TransformManager_commitLocalTransformTransaction(
        this: *mut filament_TransformManager,
    );
}
impl filament_TransformManager {
    #[inline]
    pub unsafe fn hasComponent(&self, e: utils_Entity) -> bool {
        filament_TransformManager_hasComponent(self, e)
    }
    #[inline]
    pub unsafe fn getInstance(&self, e: utils_Entity) -> filament_TransformManager_Instance {
        filament_TransformManager_getInstance(self, e)
    }
    #[inline]
    pub unsafe fn create(
        &mut self,
        entity: utils_Entity,
        parent: filament_TransformManager_Instance,
        localTransform: *const filament_math_mat4f,
    ) {
        filament_TransformManager_create(self, entity, parent, localTransform)
    }
    #[inline]
    pub unsafe fn create1(
        &mut self,
        entity: utils_Entity,
        parent: filament_TransformManager_Instance,
    ) {
        filament_TransformManager_create1(self, entity, parent)
    }
    #[inline]
    pub unsafe fn destroy(&mut self, e: utils_Entity) {
        filament_TransformManager_destroy(self, e)
    }
    #[inline]
    pub unsafe fn setParent(
        &mut self,
        i: filament_TransformManager_Instance,
        newParent: filament_TransformManager_Instance,
    ) {
        filament_TransformManager_setParent(self, i, newParent)
    }
    #[inline]
    pub unsafe fn getParent(&self, i: filament_TransformManager_Instance) -> utils_Entity {
        filament_TransformManager_getParent(self, i)
    }
    #[inline]
    pub unsafe fn getChildCount(&self, i: filament_TransformManager_Instance) -> size_t {
        filament_TransformManager_getChildCount(self, i)
    }
    #[inline]
    pub unsafe fn getChildren(
        &self,
        i: filament_TransformManager_Instance,
        children: *mut utils_Entity,
        count: size_t,
    ) -> size_t {
        filament_TransformManager_getChildren(self, i, children, count)
    }
    #[inline]
    pub unsafe fn getChildrenBegin(
        &self,
        parent: filament_TransformManager_Instance,
    ) -> filament_TransformManager_children_iterator {
        filament_TransformManager_getChildrenBegin(self, parent)
    }
    #[inline]
    pub unsafe fn getChildrenEnd(
        &self,
        parent: filament_TransformManager_Instance,
    ) -> filament_TransformManager_children_iterator {
        filament_TransformManager_getChildrenEnd(self, parent)
    }
    #[inline]
    pub unsafe fn setTransform(
        &mut self,
        ci: filament_TransformManager_Instance,
        localTransform: *const filament_math_mat4f,
    ) {
        filament_TransformManager_setTransform(self, ci, localTransform)
    }
    #[inline]
    pub unsafe fn getTransform(
        &self,
        ci: filament_TransformManager_Instance,
    ) -> *const filament_math_mat4f {
        filament_TransformManager_getTransform(self, ci)
    }
    #[inline]
    pub unsafe fn getWorldTransform(
        &self,
        ci: filament_TransformManager_Instance,
    ) -> *const filament_math_mat4f {
        filament_TransformManager_getWorldTransform(self, ci)
    }
    #[inline]
    pub unsafe fn openLocalTransformTransaction(&mut self) {
        filament_TransformManager_openLocalTransformTransaction(self)
    }
    #[inline]
    pub unsafe fn commitLocalTransformTransaction(&mut self) {
        filament_TransformManager_commitLocalTransformTransaction(self)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct helpers_BuilderProxy {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "\u{1}_ZN7helpers22renderable_builder_newEm"]
    pub fn helpers_renderable_builder_new(count: size_t) -> *mut helpers_BuilderProxy;
}
extern "C" {
    #[link_name = "\u{1}_ZN7helpers26renderable_builder_destroyEPNS_12BuilderProxyE"]
    pub fn helpers_renderable_builder_destroy(proxy: *mut helpers_BuilderProxy);
}
extern "C" {
    #[link_name = "\u{1}_ZN7helpers27renderable_builder_geometryEPNS_12BuilderProxyEmN8filament7backend13PrimitiveTypeEPNS2_12VertexBufferEPNS2_11IndexBufferE"]
    pub fn helpers_renderable_builder_geometry(
        build: *mut helpers_BuilderProxy,
        index: size_t,
        type_: filament_backend_PrimitiveType,
        vertices: *mut filament_VertexBuffer,
        indices: *mut filament_IndexBuffer,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN7helpers26renderable_builder_cullingEPNS_12BuilderProxyEb"]
    pub fn helpers_renderable_builder_culling(build: *mut helpers_BuilderProxy, culling: bool);
}
extern "C" {
    #[link_name = "\u{1}_ZN7helpers30renderable_builder_castShadowsEPNS_12BuilderProxyEb"]
    pub fn helpers_renderable_builder_castShadows(build: *mut helpers_BuilderProxy, arg1: bool);
}
extern "C" {
    #[link_name = "\u{1}_ZN7helpers33renderable_builder_receiveShadowsEPNS_12BuilderProxyEb"]
    pub fn helpers_renderable_builder_receiveShadows(build: *mut helpers_BuilderProxy, arg1: bool);
}
extern "C" {
    #[link_name = "\u{1}_ZN7helpers44renderable_builder_screenSpaceContactShadowsEPNS_12BuilderProxyEb"]
    pub fn helpers_renderable_builder_screenSpaceContactShadows(
        build: *mut helpers_BuilderProxy,
        arg1: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN7helpers27renderable_builder_morphingEPNS_12BuilderProxyEb"]
    pub fn helpers_renderable_builder_morphing(build: *mut helpers_BuilderProxy, arg1: bool);
}
extern "C" {
    #[link_name = "\u{1}_ZN7helpers27renderable_builder_materialEPNS_12BuilderProxyEmPN8filament16MaterialInstanceE"]
    pub fn helpers_renderable_builder_material(
        build: *mut helpers_BuilderProxy,
        index: size_t,
        material: *mut filament_MaterialInstance,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN7helpers24renderable_builder_buildEPNS_12BuilderProxyERN8filament6EngineEN5utils6EntityE"]
    pub fn helpers_renderable_builder_build(
        proxy: *mut helpers_BuilderProxy,
        engine: *mut filament_Engine,
        entity: utils_Entity,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN7helpers18make_SamplerParamsEN8filament7backend16SamplerMagFilterENS1_16SamplerMinFilterENS1_15SamplerWrapModeES4_S4_hNS1_18SamplerCompareModeENS1_18SamplerCompareFuncE"]
    pub fn helpers_make_SamplerParams(
        filterMag: filament_backend_SamplerMagFilter,
        filterMin: filament_backend_SamplerMinFilter,
        wrapS: filament_backend_SamplerWrapMode,
        wrapT: filament_backend_SamplerWrapMode,
        wrapR: filament_backend_SamplerWrapMode,
        anisotropyLog2: u8,
        compareMode: filament_backend_SamplerCompareMode,
        compareFunc: filament_backend_SamplerCompareFunc,
    ) -> filament_backend_SamplerParams;
}
extern "C" {
    #[link_name = "\u{1}_ZN7helpers26make_PixelBufferDescriptorEPKvmPFvPvmS2_ES2_N8filament7backend15PixelDataFormatENS6_13PixelDataTypeE"]
    pub fn helpers_make_PixelBufferDescriptor(
        buffer: *const ::std::os::raw::c_void,
        size: size_t,
        callback: filament_backend_BufferDescriptor_Callback,
        user: *mut ::std::os::raw::c_void,
        format: filament_backend_PixelDataFormat,
        ty: filament_backend_PixelDataType,
    ) -> filament_backend_PixelBufferDescriptor;
}
extern "C" {
    #[link_name = "\u{1}_ZN7helpers14material_buildERN8filament6EngineEPvm"]
    pub fn helpers_material_build(
        engine: *mut filament_Engine,
        buffer: *mut ::std::os::raw::c_void,
        len: size_t,
    ) -> *mut filament_Material;
}
extern "C" {
    #[link_name = "\u{1}_ZN7helpers27material_getDefaultInstanceEPN8filament8MaterialE"]
    pub fn helpers_material_getDefaultInstance(
        material: *mut filament_Material,
    ) -> *mut filament_MaterialInstance;
}
extern "C" {
    #[link_name = "\u{1}_ZN7helpers38material_instance_setParameter_textureEPN8filament16MaterialInstanceEPKcPKNS0_7TextureERKNS0_14TextureSamplerE"]
    pub fn helpers_material_instance_setParameter_texture(
        instance: *mut filament_MaterialInstance,
        name: *const ::std::os::raw::c_char,
        texture: *const filament_Texture,
        sampler: *const filament_TextureSampler,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4test10texture_eqERKN8filament7TextureE"]
    pub fn test_texture_eq(texture: *const filament_Texture) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_25 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_26 {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_filament_BuilderBase_open0_filament_Texture_BuilderDetails_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<filament_BuilderBase<filament_Texture_BuilderDetails>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(filament_BuilderBase<filament_Texture_BuilderDetails>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<filament_BuilderBase<filament_Texture_BuilderDetails>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(filament_BuilderBase<filament_Texture_BuilderDetails>)
        )
    );
}
#[doc = "! Returns a Frustum object in world space"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Frustum {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_filament_BuilderBase_open0_filament_VertexBuffer_BuilderDetails_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<filament_BuilderBase<filament_VertexBuffer_BuilderDetails>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(filament_BuilderBase<filament_VertexBuffer_BuilderDetails>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<filament_BuilderBase<filament_VertexBuffer_BuilderDetails>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(filament_BuilderBase<filament_VertexBuffer_BuilderDetails>)
        )
    );
}
#[test]
fn __bindgen_test_layout_filament_BuilderBase_open0_filament_IndexBuffer_BuilderDetails_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<filament_BuilderBase<filament_IndexBuffer_BuilderDetails>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(filament_BuilderBase<filament_IndexBuffer_BuilderDetails>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<filament_BuilderBase<filament_IndexBuffer_BuilderDetails>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(filament_BuilderBase<filament_IndexBuffer_BuilderDetails>)
        )
    );
}
